// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.2.0.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use crate::api::p2p_common::*;
use crate::api::p2p_dial::*;
use crate::api::p2p_event::*;
use crate::api::p2p_key::*;
use crate::api::p2p_rdv::*;
use crate::api::p2p_utils::*;
use crate::api::sled::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = DcoCodec,
    default_rust_opaque = RustOpaqueNom,
    default_rust_auto_opaque = RustAutoOpaqueNom,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.2.0";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = -1229583727;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__minimal__init_app_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_app",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::minimal::init_app();
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__p2p_common__ConnectionId_to_string_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConnectionId>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ConnectionId_to_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::p2p_common::ConnectionId::to_string(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__p2p_common__ListenerId_to_string_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ListenerId>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ListenerId_to_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::p2p_common::ListenerId::to_string(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__p2p_common__MessageId_to_string_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessageId>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MessageId_to_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(crate::api::p2p_common::MessageId::to_string(
                    &*api_that_guard,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__p2p_dial__libp2p_connected_peers_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wrapper: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "libp2p_connected_peers",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wrapper = wrapper.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::p2p_common::GenericError>(
                    (move || async move {
                        let mut api_wrapper_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_wrapper,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_wrapper_guard =
                                        Some(api_wrapper.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_wrapper_guard = api_wrapper_guard.unwrap();
                        let output_ok =
                            crate::api::p2p_dial::libp2p_connected_peers(&*api_wrapper_guard)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__p2p_dial__libp2p_connected_peers_count_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wrapper: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "libp2p_connected_peers_count",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wrapper = wrapper.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::p2p_common::GenericError>(
                    (move || async move {
                        let mut api_wrapper_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_wrapper,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_wrapper_guard =
                                        Some(api_wrapper.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_wrapper_guard = api_wrapper_guard.unwrap();
                        let output_ok =
                            crate::api::p2p_dial::libp2p_connected_peers_count(&*api_wrapper_guard)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__p2p_dial__libp2p_dial_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wrapper: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>,
    >,
    address: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "libp2p_dial_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wrapper = wrapper.cst_decode();
            let api_address = address.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::p2p_common::GenericError>(
                    (move || async move {
                        let mut api_wrapper_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_wrapper,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_wrapper_guard =
                                        Some(api_wrapper.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_wrapper_guard = api_wrapper_guard.unwrap();
                        let output_ok = crate::api::p2p_dial::libp2p_dial_address(
                            &*api_wrapper_guard,
                            api_address,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__p2p_dial__libp2p_dial_peer_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wrapper: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>,
    >,
    peerid: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "libp2p_dial_peer",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wrapper = wrapper.cst_decode();
            let api_peerid = peerid.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::p2p_common::GenericError>(
                    (move || async move {
                        let mut api_wrapper_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_wrapper,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_wrapper_guard =
                                        Some(api_wrapper.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_wrapper_guard = api_wrapper_guard.unwrap();
                        let output_ok =
                            crate::api::p2p_dial::libp2p_dial_peer(&*api_wrapper_guard, api_peerid)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__p2p_dial__libp2p_disconnect_peer_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wrapper: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>,
    >,
    peerid: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "libp2p_disconnect_peer",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wrapper = wrapper.cst_decode();
            let api_peerid = peerid.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::p2p_common::GenericError>(
                    (move || async move {
                        let mut api_wrapper_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_wrapper,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_wrapper_guard =
                                        Some(api_wrapper.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_wrapper_guard = api_wrapper_guard.unwrap();
                        let output_ok = crate::api::p2p_dial::libp2p_disconnect_peer(
                            &*api_wrapper_guard,
                            api_peerid,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__p2p_dial__libp2p_isconnected_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wrapper: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>,
    >,
    peer: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "libp2p_isconnected",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wrapper = wrapper.cst_decode();
            let api_peer = peer.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::p2p_common::GenericError>(
                    (move || async move {
                        let mut api_wrapper_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_wrapper,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_wrapper_guard =
                                        Some(api_wrapper.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_wrapper_guard = api_wrapper_guard.unwrap();
                        let output_ok =
                            crate::api::p2p_dial::libp2p_isconnected(&*api_wrapper_guard, api_peer)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__p2p_event__libp2p_add_event_listener_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wrapper: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>,
    >,
    cancellation_token: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CancellationToken>>,
    >,
    callback: impl CstDecode<flutter_rust_bridge::DartOpaque>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "libp2p_add_event_listener",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wrapper = wrapper.cst_decode();
            let api_cancellation_token = cancellation_token.cst_decode();
            let api_callback = decode_DartFn_Inputs_custom_swarm_event_Output_unit_AnyhowException(
                callback.cst_decode(),
            );
            move |context| async move {
                transform_result_dco::<_, _, crate::api::p2p_common::GenericError>(
                    (move || async move {
                        let mut api_wrapper_guard = None;
                        let mut api_cancellation_token_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_wrapper,
                                        0,
                                        false,
                                    ),
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_cancellation_token,
                                        1,
                                        false,
                                    ),
                                ],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_wrapper_guard =
                                        Some(api_wrapper.lockable_decode_async_ref().await)
                                }
                                1 => {
                                    api_cancellation_token_guard = Some(
                                        api_cancellation_token.lockable_decode_async_ref().await,
                                    )
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_wrapper_guard = api_wrapper_guard.unwrap();
                        let api_cancellation_token_guard = api_cancellation_token_guard.unwrap();
                        let output_ok = crate::api::p2p_event::libp2p_add_event_listener(
                            &*api_wrapper_guard,
                            &*api_cancellation_token_guard,
                            api_callback,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__p2p_event__libp2p_get_event_name_impl(
    event: impl CstDecode<crate::api::p2p_common::CustomSwarmEvent>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "libp2p_get_event_name",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_event = event.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::p2p_event::libp2p_get_event_name(api_event))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__p2p_factory__create_libp2p_instance_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    keypair: impl CstDecode<Keypair>,
    tcp_nodelay: impl CstDecode<bool>,
    tcp_reuse_port: impl CstDecode<bool>,
    pubsub_heartbeat_delay: impl CstDecode<u64>,
    pubsub_heartbeat_interval: impl CstDecode<u64>,
    nat_boot_delay: impl CstDecode<u64>,
    nat_retry_interval: impl CstDecode<u64>,
    nat_only_global_ips: impl CstDecode<bool>,
    nat_use_connected: impl CstDecode<bool>,
    connection_max_inout: impl CstDecode<Option<u32>>,
    connection_max_inbound: impl CstDecode<Option<u32>>,
    connection_max_outgoing: impl CstDecode<Option<u32>>,
    connection_max_pending_inbound: impl CstDecode<Option<u32>>,
    connection_max_pending_outgoing: impl CstDecode<Option<u32>>,
    memory_max_percentage: impl CstDecode<f64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_libp2p_instance",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_keypair = keypair.cst_decode();
            let api_tcp_nodelay = tcp_nodelay.cst_decode();
            let api_tcp_reuse_port = tcp_reuse_port.cst_decode();
            let api_pubsub_heartbeat_delay = pubsub_heartbeat_delay.cst_decode();
            let api_pubsub_heartbeat_interval = pubsub_heartbeat_interval.cst_decode();
            let api_nat_boot_delay = nat_boot_delay.cst_decode();
            let api_nat_retry_interval = nat_retry_interval.cst_decode();
            let api_nat_only_global_ips = nat_only_global_ips.cst_decode();
            let api_nat_use_connected = nat_use_connected.cst_decode();
            let api_connection_max_inout = connection_max_inout.cst_decode();
            let api_connection_max_inbound = connection_max_inbound.cst_decode();
            let api_connection_max_outgoing = connection_max_outgoing.cst_decode();
            let api_connection_max_pending_inbound = connection_max_pending_inbound.cst_decode();
            let api_connection_max_pending_outgoing = connection_max_pending_outgoing.cst_decode();
            let api_memory_max_percentage = memory_max_percentage.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, String>(
                    (move || async move {
                        let output_ok = crate::api::p2p_factory::create_libp2p_instance(
                            api_keypair,
                            api_tcp_nodelay,
                            api_tcp_reuse_port,
                            api_pubsub_heartbeat_delay,
                            api_pubsub_heartbeat_interval,
                            api_nat_boot_delay,
                            api_nat_retry_interval,
                            api_nat_only_global_ips,
                            api_nat_use_connected,
                            api_connection_max_inout,
                            api_connection_max_inbound,
                            api_connection_max_outgoing,
                            api_connection_max_pending_inbound,
                            api_connection_max_pending_outgoing,
                            api_memory_max_percentage,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__p2p_key__Keypair_public_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Keypair>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Keypair_public",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::p2p_key::Keypair::public(&*api_that_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__p2p_key__PeerId_to_base58_impl(
    that: impl CstDecode<PeerId>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PeerId_to_base58",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::p2p_key::PeerId::to_base58(api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__p2p_key__PeerId_to_bytes_impl(
    that: impl CstDecode<PeerId>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PeerId_to_bytes",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::p2p_key::PeerId::to_bytes(api_that))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__p2p_key__PublicKey_encode_protobuf_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PublicKey_encode_protobuf",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::p2p_key::PublicKey::encode_protobuf(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__p2p_key__PublicKey_to_peer_id_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PublicKey_to_peer_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(crate::api::p2p_key::PublicKey::to_peer_id(
                    &*api_that_guard,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__p2p_key__create_keypair_from_bytes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    key_type: impl CstDecode<crate::api::p2p_key::KeyType>,
    bytes: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_keypair_from_bytes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_key_type = key_type.cst_decode();
            let api_bytes = bytes.cst_decode();
            move |context| {
                transform_result_dco::<_, _, String>((move || {
                    let output_ok =
                        crate::api::p2p_key::create_keypair_from_bytes(api_key_type, api_bytes)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__p2p_key__create_keypair_using_random_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    key_type: impl CstDecode<crate::api::p2p_key::KeyType>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_keypair_using_random",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_key_type = key_type.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::p2p_key::create_keypair_using_random(api_key_type),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__p2p_key__keypair_from_protobuf_impl(
    proto: impl CstDecode<Vec<u8>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "keypair_from_protobuf",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_proto = proto.cst_decode();
            transform_result_dco::<_, _, String>((move || {
                let output_ok = crate::api::p2p_key::keypair_from_protobuf(api_proto)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__p2p_key__keypair_sign_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    keypair: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Keypair>>,
    >,
    msg: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "keypair_sign",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_keypair = keypair.cst_decode();
            let api_msg = msg.cst_decode();
            move |context| {
                transform_result_dco::<_, _, String>((move || {
                    let mut api_keypair_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_keypair,
                                0,
                                false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_keypair_guard = Some(api_keypair.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_keypair_guard = api_keypair_guard.unwrap();
                    let output_ok =
                        crate::api::p2p_key::keypair_sign(&*api_keypair_guard, api_msg)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__p2p_key__keypair_to_protobuf_impl(
    keypair: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Keypair>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "keypair_to_protobuf",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_keypair = keypair.cst_decode();
            transform_result_dco::<_, _, String>((move || {
                let mut api_keypair_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_keypair,
                            0,
                            false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_keypair_guard = Some(api_keypair.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_keypair_guard = api_keypair_guard.unwrap();
                let output_ok = crate::api::p2p_key::keypair_to_protobuf(&*api_keypair_guard)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__p2p_key__keypair_verify_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    key: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>,
    >,
    msg: impl CstDecode<Vec<u8>>,
    sig: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "keypair_verify",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_key = key.cst_decode();
            let api_msg = msg.cst_decode();
            let api_sig = sig.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_key_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_key, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_key_guard = Some(api_key.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_key_guard = api_key_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(crate::api::p2p_key::keypair_verify(
                        &*api_key_guard,
                        api_msg,
                        api_sig,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__p2p_listen__libp2p_listen_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wrapper: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>,
    >,
    address: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "libp2p_listen",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wrapper = wrapper.cst_decode();
            let api_address = address.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::p2p_common::GenericError>(
                    (move || async move {
                        let mut api_wrapper_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_wrapper,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_wrapper_guard =
                                        Some(api_wrapper.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_wrapper_guard = api_wrapper_guard.unwrap();
                        let output_ok =
                            crate::api::p2p_listen::libp2p_listen(&*api_wrapper_guard, api_address)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__p2p_listen__libp2p_unlisten_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wrapper: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>,
    >,
    listener_id: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ListenerId>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "libp2p_unlisten",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wrapper = wrapper.cst_decode();
            let api_listener_id = listener_id.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::p2p_common::GenericError>(
                    (move || async move {
                        let mut api_wrapper_guard = None;
                        let mut api_listener_id_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_wrapper,
                                        0,
                                        false,
                                    ),
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_listener_id,
                                        1,
                                        false,
                                    ),
                                ],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_wrapper_guard =
                                        Some(api_wrapper.lockable_decode_async_ref().await)
                                }
                                1 => {
                                    api_listener_id_guard =
                                        Some(api_listener_id.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_wrapper_guard = api_wrapper_guard.unwrap();
                        let api_listener_id_guard = api_listener_id_guard.unwrap();
                        let output_ok = crate::api::p2p_listen::libp2p_unlisten(
                            &*api_wrapper_guard,
                            &*api_listener_id_guard,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__p2p_nat__libp2p_autonat_add_server_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wrapper: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>,
    >,
    peer: impl CstDecode<String>,
    address: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "libp2p_autonat_add_server",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wrapper = wrapper.cst_decode();
            let api_peer = peer.cst_decode();
            let api_address = address.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::p2p_common::GenericError>(
                    (move || async move {
                        let mut api_wrapper_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_wrapper,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_wrapper_guard =
                                        Some(api_wrapper.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_wrapper_guard = api_wrapper_guard.unwrap();
                        let output_ok = crate::api::p2p_nat::libp2p_autonat_add_server(
                            &*api_wrapper_guard,
                            api_peer,
                            api_address,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__p2p_nat__libp2p_autonat_status_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wrapper: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "libp2p_autonat_status",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wrapper = wrapper.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::p2p_common::GenericError>(
                    (move || async move {
                        let mut api_wrapper_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_wrapper,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_wrapper_guard =
                                        Some(api_wrapper.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_wrapper_guard = api_wrapper_guard.unwrap();
                        let output_ok =
                            crate::api::p2p_nat::libp2p_autonat_status(&*api_wrapper_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__p2p_pubsub__libp2p_publish_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wrapper: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>,
    >,
    topic: impl CstDecode<String>,
    data: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "libp2p_publish",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wrapper = wrapper.cst_decode();
            let api_topic = topic.cst_decode();
            let api_data = data.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::p2p_common::GenericError>(
                    (move || async move {
                        let mut api_wrapper_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_wrapper,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_wrapper_guard =
                                        Some(api_wrapper.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_wrapper_guard = api_wrapper_guard.unwrap();
                        let output_ok = crate::api::p2p_pubsub::libp2p_publish(
                            &*api_wrapper_guard,
                            api_topic,
                            api_data,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__p2p_pubsub__libp2p_pubsub_add_peer_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wrapper: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>,
    >,
    peer: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "libp2p_pubsub_add_peer",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wrapper = wrapper.cst_decode();
            let api_peer = peer.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::p2p_common::GenericError>(
                    (move || async move {
                        let mut api_wrapper_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_wrapper,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_wrapper_guard =
                                        Some(api_wrapper.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_wrapper_guard = api_wrapper_guard.unwrap();
                        let output_ok = crate::api::p2p_pubsub::libp2p_pubsub_add_peer(
                            &*api_wrapper_guard,
                            api_peer,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__p2p_pubsub__libp2p_pubsub_remove_peer_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wrapper: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>,
    >,
    peer: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "libp2p_pubsub_remove_peer",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wrapper = wrapper.cst_decode();
            let api_peer = peer.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::p2p_common::GenericError>(
                    (move || async move {
                        let mut api_wrapper_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_wrapper,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_wrapper_guard =
                                        Some(api_wrapper.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_wrapper_guard = api_wrapper_guard.unwrap();
                        let output_ok = crate::api::p2p_pubsub::libp2p_pubsub_remove_peer(
                            &*api_wrapper_guard,
                            api_peer,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__p2p_pubsub__libp2p_pubsub_validate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wrapper: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>,
    >,
    msg_id: impl CstDecode<Vec<u8>>,
    propagation_source: impl CstDecode<String>,
    acceptance: impl CstDecode<crate::api::p2p_pubsub::CustomMessageAcceptance>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "libp2p_pubsub_validate",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wrapper = wrapper.cst_decode();
            let api_msg_id = msg_id.cst_decode();
            let api_propagation_source = propagation_source.cst_decode();
            let api_acceptance = acceptance.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::p2p_common::GenericError>(
                    (move || async move {
                        let mut api_wrapper_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_wrapper,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_wrapper_guard =
                                        Some(api_wrapper.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_wrapper_guard = api_wrapper_guard.unwrap();
                        let output_ok = crate::api::p2p_pubsub::libp2p_pubsub_validate(
                            &*api_wrapper_guard,
                            api_msg_id,
                            api_propagation_source,
                            api_acceptance,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__p2p_pubsub__libp2p_subscribe_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wrapper: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>,
    >,
    topic: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "libp2p_subscribe",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wrapper = wrapper.cst_decode();
            let api_topic = topic.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::p2p_common::GenericError>(
                    (move || async move {
                        let mut api_wrapper_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_wrapper,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_wrapper_guard =
                                        Some(api_wrapper.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_wrapper_guard = api_wrapper_guard.unwrap();
                        let output_ok = crate::api::p2p_pubsub::libp2p_subscribe(
                            &*api_wrapper_guard,
                            api_topic,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__p2p_pubsub__libp2p_topic_tohash_impl(
    topic: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "libp2p_topic_tohash",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_topic = topic.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::p2p_pubsub::libp2p_topic_tohash(api_topic))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__p2p_pubsub__libp2p_unsubscribe_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wrapper: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>,
    >,
    topic: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "libp2p_unsubscribe",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wrapper = wrapper.cst_decode();
            let api_topic = topic.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::p2p_common::GenericError>(
                    (move || async move {
                        let mut api_wrapper_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_wrapper,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_wrapper_guard =
                                        Some(api_wrapper.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_wrapper_guard = api_wrapper_guard.unwrap();
                        let output_ok = crate::api::p2p_pubsub::libp2p_unsubscribe(
                            &*api_wrapper_guard,
                            api_topic,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__p2p_rdv__Cookie_clone_impl(
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Cookie>>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Cookie_clone",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::p2p_rdv::Cookie::clone(&*api_that_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__p2p_rdv__libp2p_rdv_cookie_impl(
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "libp2p_rdv_cookie",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::p2p_rdv::libp2p_rdv_cookie())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__p2p_rdv__libp2p_rdv_discover_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wrapper: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>,
    >,
    rdv_peerid: impl CstDecode<String>,
    limit: impl CstDecode<Option<u64>>,
    cookie: impl CstDecode<Option<Cookie>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "libp2p_rdv_discover",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wrapper = wrapper.cst_decode();
            let api_rdv_peerid = rdv_peerid.cst_decode();
            let api_limit = limit.cst_decode();
            let api_cookie = cookie.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::p2p_common::GenericError>(
                    (move || async move {
                        let mut api_wrapper_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_wrapper,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_wrapper_guard =
                                        Some(api_wrapper.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_wrapper_guard = api_wrapper_guard.unwrap();
                        let output_ok = crate::api::p2p_rdv::libp2p_rdv_discover(
                            &*api_wrapper_guard,
                            api_rdv_peerid,
                            api_limit,
                            api_cookie,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__p2p_rdv__libp2p_rdv_register_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wrapper: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>,
    >,
    rdv_peerid: impl CstDecode<String>,
    namespace: impl CstDecode<String>,
    ttl: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "libp2p_rdv_register",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wrapper = wrapper.cst_decode();
            let api_rdv_peerid = rdv_peerid.cst_decode();
            let api_namespace = namespace.cst_decode();
            let api_ttl = ttl.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::p2p_common::GenericError>(
                    (move || async move {
                        let mut api_wrapper_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_wrapper,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_wrapper_guard =
                                        Some(api_wrapper.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_wrapper_guard = api_wrapper_guard.unwrap();
                        let output_ok = crate::api::p2p_rdv::libp2p_rdv_register(
                            &*api_wrapper_guard,
                            api_rdv_peerid,
                            api_namespace,
                            api_ttl,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__p2p_request__libp2p_close_response_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    channel: impl CstDecode<ResponseChannel<Vec<u8>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "libp2p_close_response",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_channel = channel.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok({
                            crate::api::p2p_request::libp2p_close_response(api_channel).await;
                        })?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__p2p_request__libp2p_send_request_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wrapper: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>,
    >,
    peerid: impl CstDecode<String>,
    request: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "libp2p_send_request",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wrapper = wrapper.cst_decode();
            let api_peerid = peerid.cst_decode();
            let api_request = request.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::p2p_common::GenericError>(
                    (move || async move {
                        let mut api_wrapper_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_wrapper,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_wrapper_guard =
                                        Some(api_wrapper.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_wrapper_guard = api_wrapper_guard.unwrap();
                        let output_ok = crate::api::p2p_request::libp2p_send_request(
                            &*api_wrapper_guard,
                            api_peerid,
                            api_request,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__p2p_request__libp2p_send_response_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wrapper: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>,
    >,
    channel: impl CstDecode<ResponseChannel<Vec<u8>>>,
    response: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "libp2p_send_response",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wrapper = wrapper.cst_decode();
            let api_channel = channel.cst_decode();
            let api_response = response.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::p2p_common::GenericError>(
                    (move || async move {
                        let mut api_wrapper_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_wrapper,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_wrapper_guard =
                                        Some(api_wrapper.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_wrapper_guard = api_wrapper_guard.unwrap();
                        let output_ok = crate::api::p2p_request::libp2p_send_response(
                            &*api_wrapper_guard,
                            api_channel,
                            api_response,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__p2p_utils__CancellationToken_cancel_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CancellationToken>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "CancellationToken_cancel",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    crate::api::p2p_utils::CancellationToken::cancel(&*api_that_guard);
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__p2p_utils__CancellationToken_is_cancelled_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CancellationToken>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "CancellationToken_is_cancelled",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::p2p_utils::CancellationToken::is_cancelled(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__p2p_utils__create_cancellation_token_impl(
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_cancellation_token",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::p2p_utils::create_cancellation_token())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__p2p_utils__libp2p_add_blacklist_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wrapper: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>,
    >,
    peer: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "libp2p_add_blacklist",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wrapper = wrapper.cst_decode();
            let api_peer = peer.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::p2p_common::GenericError>(
                    (move || async move {
                        let mut api_wrapper_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_wrapper,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_wrapper_guard =
                                        Some(api_wrapper.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_wrapper_guard = api_wrapper_guard.unwrap();
                        let output_ok = crate::api::p2p_utils::libp2p_add_blacklist(
                            &*api_wrapper_guard,
                            api_peer,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__p2p_utils__libp2p_add_external_address_impl(
    wrapper: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>,
    >,
    address: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "libp2p_add_external_address",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_wrapper = wrapper.cst_decode();
            let api_address = address.cst_decode();
            transform_result_dco::<_, _, crate::api::p2p_common::GenericError>((move || {
                let mut api_wrapper_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_wrapper,
                            0,
                            false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_wrapper_guard = Some(api_wrapper.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_wrapper_guard = api_wrapper_guard.unwrap();
                let output_ok = crate::api::p2p_utils::libp2p_add_external_address(
                    &*api_wrapper_guard,
                    api_address,
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__p2p_utils__libp2p_close_connection_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wrapper: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>,
    >,
    connection_id: impl CstDecode<ConnectionId>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "libp2p_close_connection",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wrapper = wrapper.cst_decode();
            let api_connection_id = connection_id.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::p2p_common::GenericError>(
                    (move || async move {
                        let mut api_wrapper_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_wrapper,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_wrapper_guard =
                                        Some(api_wrapper.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_wrapper_guard = api_wrapper_guard.unwrap();
                        let output_ok = crate::api::p2p_utils::libp2p_close_connection(
                            &*api_wrapper_guard,
                            api_connection_id,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__p2p_utils__libp2p_peerid_impl(
    wrapper: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "libp2p_peerid",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_wrapper = wrapper.cst_decode();
            transform_result_dco::<_, _, crate::api::p2p_common::GenericError>((move || {
                let mut api_wrapper_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_wrapper,
                            0,
                            false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_wrapper_guard = Some(api_wrapper.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_wrapper_guard = api_wrapper_guard.unwrap();
                let output_ok = crate::api::p2p_utils::libp2p_peerid(&*api_wrapper_guard)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__p2p_utils__libp2p_peerid_random_impl(
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "libp2p_peerid_random",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::p2p_utils::libp2p_peerid_random())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__p2p_utils__libp2p_remove_blacklist_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    wrapper: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>,
    >,
    peer: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "libp2p_remove_blacklist",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_wrapper = wrapper.cst_decode();
            let api_peer = peer.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::p2p_common::GenericError>(
                    (move || async move {
                        let mut api_wrapper_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_wrapper,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_wrapper_guard =
                                        Some(api_wrapper.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_wrapper_guard = api_wrapper_guard.unwrap();
                        let output_ok = crate::api::p2p_utils::libp2p_remove_blacklist(
                            &*api_wrapper_guard,
                            api_peer,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__sled__CustomBatch_auto_accessor_get_deletes_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CustomBatch>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "CustomBatch_auto_accessor_get_deletes",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.deletes.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__sled__CustomBatch_auto_accessor_get_upserts_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CustomBatch>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "CustomBatch_auto_accessor_get_upserts",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.upserts.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__sled__CustomBatch_auto_accessor_set_deletes_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CustomBatch>>,
    >,
    deletes: impl CstDecode<Vec<Vec<u8>>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "CustomBatch_auto_accessor_set_deletes",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_deletes = deletes.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.deletes = api_deletes;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__sled__CustomBatch_auto_accessor_set_upserts_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CustomBatch>>,
    >,
    upserts: impl CstDecode<Vec<(Vec<u8>, Vec<u8>)>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "CustomBatch_auto_accessor_set_upserts",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_upserts = upserts.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.upserts = api_upserts;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__sled__sled_db_close_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    db: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<CustomDB>>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sled_db_close",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_db = db.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, String>(
                    (move || async move {
                        let mut api_db_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_db, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_db_guard = Some(api_db.lockable_decode_async_ref().await),
                                _ => unreachable!(),
                            }
                        }
                        let api_db_guard = api_db_guard.unwrap();
                        let output_ok = crate::api::sled::sled_db_close(&*api_db_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__sled__sled_db_contains_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    db: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<CustomDB>>>,
    >,
    key: impl CstDecode<Vec<u8>>,
    tree: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sled_db_contains",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_db = db.cst_decode();
            let api_key = key.cst_decode();
            let api_tree = tree.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, String>(
                    (move || async move {
                        let mut api_db_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_db, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_db_guard = Some(api_db.lockable_decode_async_ref().await),
                                _ => unreachable!(),
                            }
                        }
                        let api_db_guard = api_db_guard.unwrap();
                        let output_ok =
                            crate::api::sled::sled_db_contains(&*api_db_guard, api_key, api_tree)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__sled__sled_db_count_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    db: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<CustomDB>>>,
    >,
    tree: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sled_db_count",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_db = db.cst_decode();
            let api_tree = tree.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, String>(
                    (move || async move {
                        let mut api_db_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_db, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_db_guard = Some(api_db.lockable_decode_async_ref().await),
                                _ => unreachable!(),
                            }
                        }
                        let api_db_guard = api_db_guard.unwrap();
                        let output_ok =
                            crate::api::sled::sled_db_count(&*api_db_guard, api_tree).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__sled__sled_db_delete_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    db: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<CustomDB>>>,
    >,
    key: impl CstDecode<Vec<u8>>,
    tree: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sled_db_delete",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_db = db.cst_decode();
            let api_key = key.cst_decode();
            let api_tree = tree.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, String>(
                    (move || async move {
                        let mut api_db_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_db, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_db_guard = Some(api_db.lockable_decode_async_ref().await),
                                _ => unreachable!(),
                            }
                        }
                        let api_db_guard = api_db_guard.unwrap();
                        let output_ok =
                            crate::api::sled::sled_db_delete(&*api_db_guard, api_key, api_tree)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__sled__sled_db_delete_all_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    db: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<CustomDB>>>,
    >,
    tree: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sled_db_delete_all",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_db = db.cst_decode();
            let api_tree = tree.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, String>(
                    (move || async move {
                        let mut api_db_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_db, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_db_guard = Some(api_db.lockable_decode_async_ref().await),
                                _ => unreachable!(),
                            }
                        }
                        let api_db_guard = api_db_guard.unwrap();
                        let output_ok =
                            crate::api::sled::sled_db_delete_all(&*api_db_guard, api_tree).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__sled__sled_db_drop_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    db: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<CustomDB>>>,
    >,
    tree: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sled_db_drop",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_db = db.cst_decode();
            let api_tree = tree.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, String>(
                    (move || async move {
                        let mut api_db_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_db, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_db_guard = Some(api_db.lockable_decode_async_ref().await),
                                _ => unreachable!(),
                            }
                        }
                        let api_db_guard = api_db_guard.unwrap();
                        let output_ok =
                            crate::api::sled::sled_db_drop(&*api_db_guard, api_tree).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__sled__sled_db_flush_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    db: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<CustomDB>>>,
    >,
    tree: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sled_db_flush",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_db = db.cst_decode();
            let api_tree = tree.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, String>(
                    (move || async move {
                        let mut api_db_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_db, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_db_guard = Some(api_db.lockable_decode_async_ref().await),
                                _ => unreachable!(),
                            }
                        }
                        let api_db_guard = api_db_guard.unwrap();
                        let output_ok =
                            crate::api::sled::sled_db_flush(&*api_db_guard, api_tree).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__sled__sled_db_get_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    db: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<CustomDB>>>,
    >,
    key: impl CstDecode<Vec<u8>>,
    tree: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sled_db_get",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_db = db.cst_decode();
            let api_key = key.cst_decode();
            let api_tree = tree.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, String>(
                    (move || async move {
                        let mut api_db_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_db, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_db_guard = Some(api_db.lockable_decode_async_ref().await),
                                _ => unreachable!(),
                            }
                        }
                        let api_db_guard = api_db_guard.unwrap();
                        let output_ok =
                            crate::api::sled::sled_db_get(&*api_db_guard, api_key, api_tree)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__sled__sled_db_get_next_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    db: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<CustomDB>>>,
    >,
    key: impl CstDecode<Vec<u8>>,
    tree: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sled_db_get_next",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_db = db.cst_decode();
            let api_key = key.cst_decode();
            let api_tree = tree.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, String>(
                    (move || async move {
                        let mut api_db_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_db, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_db_guard = Some(api_db.lockable_decode_async_ref().await),
                                _ => unreachable!(),
                            }
                        }
                        let api_db_guard = api_db_guard.unwrap();
                        let output_ok =
                            crate::api::sled::sled_db_get_next(&*api_db_guard, api_key, api_tree)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__sled__sled_db_get_previous_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    db: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<CustomDB>>>,
    >,
    key: impl CstDecode<Vec<u8>>,
    tree: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sled_db_get_previous",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_db = db.cst_decode();
            let api_key = key.cst_decode();
            let api_tree = tree.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, String>(
                    (move || async move {
                        let mut api_db_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_db, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_db_guard = Some(api_db.lockable_decode_async_ref().await),
                                _ => unreachable!(),
                            }
                        }
                        let api_db_guard = api_db_guard.unwrap();
                        let output_ok = crate::api::sled::sled_db_get_previous(
                            &*api_db_guard,
                            api_key,
                            api_tree,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__sled__sled_db_key_from_string_impl(
    key: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sled_db_key_from_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_key = key.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::sled::sled_db_key_from_string(api_key))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__sled__sled_db_key_prefix_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    db: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<CustomDB>>>,
    >,
    prefix: impl CstDecode<String>,
    limit: impl CstDecode<Option<usize>>,
    tree: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sled_db_key_prefix",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_db = db.cst_decode();
            let api_prefix = prefix.cst_decode();
            let api_limit = limit.cst_decode();
            let api_tree = tree.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, String>(
                    (move || async move {
                        let mut api_db_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_db, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_db_guard = Some(api_db.lockable_decode_async_ref().await),
                                _ => unreachable!(),
                            }
                        }
                        let api_db_guard = api_db_guard.unwrap();
                        let output_ok = crate::api::sled::sled_db_key_prefix(
                            &*api_db_guard,
                            api_prefix,
                            api_limit,
                            api_tree,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__sled__sled_db_key_prefix_fn_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    db: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<CustomDB>>>,
    >,
    prefix: impl CstDecode<String>,
    tree: impl CstDecode<Option<String>>,
    callback: impl CstDecode<flutter_rust_bridge::DartOpaque>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sled_db_key_prefix_fn",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_db = db.cst_decode();
            let api_prefix = prefix.cst_decode();
            let api_tree = tree.cst_decode();
            let api_callback =
                decode_DartFn_Inputs_list_prim_u_8_strict_Output_bool_AnyhowException(
                    callback.cst_decode(),
                );
            move |context| async move {
                transform_result_dco::<_, _, String>(
                    (move || async move {
                        let mut api_db_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_db, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_db_guard = Some(api_db.lockable_decode_async_ref().await),
                                _ => unreachable!(),
                            }
                        }
                        let api_db_guard = api_db_guard.unwrap();
                        let output_ok = crate::api::sled::sled_db_key_prefix_fn(
                            &*api_db_guard,
                            api_prefix,
                            api_tree,
                            api_callback,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__sled__sled_db_key_range_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    db: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<CustomDB>>>,
    >,
    start: impl CstDecode<Option<String>>,
    end: impl CstDecode<Option<String>>,
    limit: impl CstDecode<Option<usize>>,
    tree: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sled_db_key_range",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_db = db.cst_decode();
            let api_start = start.cst_decode();
            let api_end = end.cst_decode();
            let api_limit = limit.cst_decode();
            let api_tree = tree.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, String>(
                    (move || async move {
                        let mut api_db_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_db, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_db_guard = Some(api_db.lockable_decode_async_ref().await),
                                _ => unreachable!(),
                            }
                        }
                        let api_db_guard = api_db_guard.unwrap();
                        let output_ok = crate::api::sled::sled_db_key_range(
                            &*api_db_guard,
                            api_start,
                            api_end,
                            api_limit,
                            api_tree,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__sled__sled_db_key_range_fn_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    db: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<CustomDB>>>,
    >,
    start: impl CstDecode<Option<String>>,
    end: impl CstDecode<Option<String>>,
    tree: impl CstDecode<Option<String>>,
    callback: impl CstDecode<flutter_rust_bridge::DartOpaque>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sled_db_key_range_fn",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_db = db.cst_decode();
            let api_start = start.cst_decode();
            let api_end = end.cst_decode();
            let api_tree = tree.cst_decode();
            let api_callback =
                decode_DartFn_Inputs_list_prim_u_8_strict_Output_bool_AnyhowException(
                    callback.cst_decode(),
                );
            move |context| async move {
                transform_result_dco::<_, _, String>(
                    (move || async move {
                        let mut api_db_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_db, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_db_guard = Some(api_db.lockable_decode_async_ref().await),
                                _ => unreachable!(),
                            }
                        }
                        let api_db_guard = api_db_guard.unwrap();
                        let output_ok = crate::api::sled::sled_db_key_range_fn(
                            &*api_db_guard,
                            api_start,
                            api_end,
                            api_tree,
                            api_callback,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__sled__sled_db_key_to_string_impl(
    key: impl CstDecode<Vec<u8>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sled_db_key_to_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_key = key.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::sled::sled_db_key_to_string(api_key))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__sled__sled_db_key_value_prefix_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    db: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<CustomDB>>>,
    >,
    prefix: impl CstDecode<String>,
    limit: impl CstDecode<Option<usize>>,
    tree: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sled_db_key_value_prefix",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_db = db.cst_decode();
            let api_prefix = prefix.cst_decode();
            let api_limit = limit.cst_decode();
            let api_tree = tree.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, String>(
                    (move || async move {
                        let mut api_db_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_db, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_db_guard = Some(api_db.lockable_decode_async_ref().await),
                                _ => unreachable!(),
                            }
                        }
                        let api_db_guard = api_db_guard.unwrap();
                        let output_ok = crate::api::sled::sled_db_key_value_prefix(
                            &*api_db_guard,
                            api_prefix,
                            api_limit,
                            api_tree,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__sled__sled_db_key_value_prefix_fn_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    db: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<CustomDB>>>,
    >,
    prefix: impl CstDecode<String>,
    tree: impl CstDecode<Option<String>>,
    callback: impl CstDecode<flutter_rust_bridge::DartOpaque>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "sled_db_key_value_prefix_fn", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { let api_db = db.cst_decode();let api_prefix = prefix.cst_decode();let api_tree = tree.cst_decode();let api_callback = decode_DartFn_Inputs_list_prim_u_8_strict_list_prim_u_8_strict_Output_bool_AnyhowException(callback.cst_decode()); move |context| async move {
                    transform_result_dco::<_, _, String>((move || async move {
                        let mut api_db_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_db, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_db_guard = Some(api_db.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_db_guard = api_db_guard.unwrap();
 let output_ok = crate::api::sled::sled_db_key_value_prefix_fn(&*api_db_guard, api_prefix, api_tree, api_callback).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__sled__sled_db_key_value_range_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    db: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<CustomDB>>>,
    >,
    start: impl CstDecode<Option<String>>,
    end: impl CstDecode<Option<String>>,
    limit: impl CstDecode<Option<usize>>,
    tree: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sled_db_key_value_range",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_db = db.cst_decode();
            let api_start = start.cst_decode();
            let api_end = end.cst_decode();
            let api_limit = limit.cst_decode();
            let api_tree = tree.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, String>(
                    (move || async move {
                        let mut api_db_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_db, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_db_guard = Some(api_db.lockable_decode_async_ref().await),
                                _ => unreachable!(),
                            }
                        }
                        let api_db_guard = api_db_guard.unwrap();
                        let output_ok = crate::api::sled::sled_db_key_value_range(
                            &*api_db_guard,
                            api_start,
                            api_end,
                            api_limit,
                            api_tree,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__sled__sled_db_key_value_range_fn_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    db: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<CustomDB>>>,
    >,
    start: impl CstDecode<Option<String>>,
    end: impl CstDecode<Option<String>>,
    tree: impl CstDecode<Option<String>>,
    callback: impl CstDecode<flutter_rust_bridge::DartOpaque>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "sled_db_key_value_range_fn", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { let api_db = db.cst_decode();let api_start = start.cst_decode();let api_end = end.cst_decode();let api_tree = tree.cst_decode();let api_callback = decode_DartFn_Inputs_list_prim_u_8_strict_list_prim_u_8_strict_Output_bool_AnyhowException(callback.cst_decode()); move |context| async move {
                    transform_result_dco::<_, _, String>((move || async move {
                        let mut api_db_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_db, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_db_guard = Some(api_db.lockable_decode_async_ref().await),
                _ => unreachable!(),
            }
        }
        let api_db_guard = api_db_guard.unwrap();
 let output_ok = crate::api::sled::sled_db_key_value_range_fn(&*api_db_guard, api_start, api_end, api_tree, api_callback).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__sled__sled_db_open_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    path: impl CstDecode<String>,
    compression: impl CstDecode<bool>,
    temporary: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sled_db_open",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_path = path.cst_decode();
            let api_compression = compression.cst_decode();
            let api_temporary = temporary.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, String>(
                    (move || async move {
                        let output_ok = crate::api::sled::sled_db_open(
                            api_path,
                            api_compression,
                            api_temporary,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__sled__sled_db_transaction_begin_impl(
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sled_db_transaction_begin",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::sled::sled_db_transaction_begin())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__sled__sled_db_transaction_commit_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    db: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<CustomDB>>>,
    >,
    batch: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CustomBatch>>,
    >,
    tree: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sled_db_transaction_commit",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_db = db.cst_decode();
            let api_batch = batch.cst_decode();
            let api_tree = tree.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, String>(
                    (move || async move {
                        let mut api_db_guard = None;
                        let mut api_batch_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_db, 0, false,
                                    ),
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_batch, 1, false,
                                    ),
                                ],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_db_guard = Some(api_db.lockable_decode_async_ref().await),
                                1 => {
                                    api_batch_guard =
                                        Some(api_batch.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_db_guard = api_db_guard.unwrap();
                        let api_batch_guard = api_batch_guard.unwrap();
                        let output_ok = crate::api::sled::sled_db_transaction_commit(
                            &*api_db_guard,
                            &*api_batch_guard,
                            api_tree,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__sled__sled_db_upsert_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    db: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<CustomDB>>>,
    >,
    key: impl CstDecode<Vec<u8>>,
    value: impl CstDecode<Vec<u8>>,
    tree: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sled_db_upsert",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_db = db.cst_decode();
            let api_key = key.cst_decode();
            let api_value = value.cst_decode();
            let api_tree = tree.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, String>(
                    (move || async move {
                        let mut api_db_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_db, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_db_guard = Some(api_db.lockable_decode_async_ref().await),
                                _ => unreachable!(),
                            }
                        }
                        let api_db_guard = api_db_guard.unwrap();
                        let output_ok = crate::api::sled::sled_db_upsert(
                            &*api_db_guard,
                            api_key,
                            api_value,
                            api_tree,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}

// Section: related_funcs

fn decode_DartFn_Inputs_custom_swarm_event_Output_unit_AnyhowException(
    dart_opaque: flutter_rust_bridge::DartOpaque,
) -> impl Fn(crate::api::p2p_common::CustomSwarmEvent) -> flutter_rust_bridge::DartFnFuture<()> {
    use flutter_rust_bridge::IntoDart;

    async fn body(
        dart_opaque: flutter_rust_bridge::DartOpaque,
        arg0: crate::api::p2p_common::CustomSwarmEvent,
    ) -> () {
        let args = vec![arg0.into_into_dart().into_dart()];
        let message = FLUTTER_RUST_BRIDGE_HANDLER
            .dart_fn_invoke(dart_opaque, args)
            .await;

        let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
        let action = deserializer.cursor.read_u8().unwrap();
        let ans = match action {
            0 => std::result::Result::Ok(<()>::sse_decode(&mut deserializer)),
            1 => std::result::Result::Err(
                <flutter_rust_bridge::for_generated::anyhow::Error>::sse_decode(&mut deserializer),
            ),
            _ => unreachable!(),
        };
        deserializer.end();
        let ans = ans.expect("Dart throws exception but Rust side assume it is not failable");
        ans
    }

    move |arg0: crate::api::p2p_common::CustomSwarmEvent| {
        flutter_rust_bridge::for_generated::convert_into_dart_fn_future(body(
            dart_opaque.clone(),
            arg0,
        ))
    }
}
fn decode_DartFn_Inputs_list_prim_u_8_strict_Output_bool_AnyhowException(
    dart_opaque: flutter_rust_bridge::DartOpaque,
) -> impl Fn(Vec<u8>) -> flutter_rust_bridge::DartFnFuture<bool> {
    use flutter_rust_bridge::IntoDart;

    async fn body(dart_opaque: flutter_rust_bridge::DartOpaque, arg0: Vec<u8>) -> bool {
        let args = vec![arg0.into_into_dart().into_dart()];
        let message = FLUTTER_RUST_BRIDGE_HANDLER
            .dart_fn_invoke(dart_opaque, args)
            .await;

        let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
        let action = deserializer.cursor.read_u8().unwrap();
        let ans = match action {
            0 => std::result::Result::Ok(<bool>::sse_decode(&mut deserializer)),
            1 => std::result::Result::Err(
                <flutter_rust_bridge::for_generated::anyhow::Error>::sse_decode(&mut deserializer),
            ),
            _ => unreachable!(),
        };
        deserializer.end();
        let ans = ans.expect("Dart throws exception but Rust side assume it is not failable");
        ans
    }

    move |arg0: Vec<u8>| {
        flutter_rust_bridge::for_generated::convert_into_dart_fn_future(body(
            dart_opaque.clone(),
            arg0,
        ))
    }
}
fn decode_DartFn_Inputs_list_prim_u_8_strict_list_prim_u_8_strict_Output_bool_AnyhowException(
    dart_opaque: flutter_rust_bridge::DartOpaque,
) -> impl Fn(Vec<u8>, Vec<u8>) -> flutter_rust_bridge::DartFnFuture<bool> {
    use flutter_rust_bridge::IntoDart;

    async fn body(
        dart_opaque: flutter_rust_bridge::DartOpaque,
        arg0: Vec<u8>,
        arg1: Vec<u8>,
    ) -> bool {
        let args = vec![
            arg0.into_into_dart().into_dart(),
            arg1.into_into_dart().into_dart(),
        ];
        let message = FLUTTER_RUST_BRIDGE_HANDLER
            .dart_fn_invoke(dart_opaque, args)
            .await;

        let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
        let action = deserializer.cursor.read_u8().unwrap();
        let ans = match action {
            0 => std::result::Result::Ok(<bool>::sse_decode(&mut deserializer)),
            1 => std::result::Result::Err(
                <flutter_rust_bridge::for_generated::anyhow::Error>::sse_decode(&mut deserializer),
            ),
            _ => unreachable!(),
        };
        deserializer.end();
        let ans = ans.expect("Dart throws exception but Rust side assume it is not failable");
        ans
    }

    move |arg0: Vec<u8>, arg1: Vec<u8>| {
        flutter_rust_bridge::for_generated::convert_into_dart_fn_future(body(
            dart_opaque.clone(),
            arg0,
            arg1,
        ))
    }
}

// Section: dart2rust

impl CstDecode<bool> for bool {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> bool {
        self
    }
}
impl CstDecode<crate::api::p2p_pubsub::CustomMessageAcceptance> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::p2p_pubsub::CustomMessageAcceptance {
        match self {
            0 => crate::api::p2p_pubsub::CustomMessageAcceptance::Reject,
            1 => crate::api::p2p_pubsub::CustomMessageAcceptance::Ignore,
            2 => crate::api::p2p_pubsub::CustomMessageAcceptance::Accept,
            _ => unreachable!("Invalid variant for CustomMessageAcceptance: {}", self),
        }
    }
}
impl CstDecode<f64> for f64 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> f64 {
        self
    }
}
impl CstDecode<i32> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> i32 {
        self
    }
}
impl CstDecode<crate::api::p2p_key::KeyType> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::p2p_key::KeyType {
        match self {
            0 => crate::api::p2p_key::KeyType::Ed25519,
            1 => crate::api::p2p_key::KeyType::Rsa,
            2 => crate::api::p2p_key::KeyType::Secp256k1,
            3 => crate::api::p2p_key::KeyType::Ecdsa,
            _ => unreachable!("Invalid variant for KeyType: {}", self),
        }
    }
}
impl CstDecode<u32> for u32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u32 {
        self
    }
}
impl CstDecode<u64> for u64 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u64 {
        self
    }
}
impl CstDecode<u8> for u8 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u8 {
        self
    }
}
impl CstDecode<usize> for usize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> usize {
        self
    }
}
impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!("{}", inner);
    }
}

impl SseDecode for RustAutoOpaqueNom<ResponseChannel<Vec<u8>>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ResponseChannel<Vec<u8>>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_explicit_decode(inner);
    }
}

impl SseDecode for Arc<CustomDB> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<CustomDB>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Arc<Wrapper> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for CancellationToken {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CancellationToken>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ConnectionId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConnectionId>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Cookie {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Cookie>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for CustomBatch {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CustomBatch>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Keypair {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Keypair>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ListenerId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ListenerId>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for MessageId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessageId>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for PeerId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerId>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for PublicKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ResponseChannel<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ResponseChannel<Vec<u8>>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for flutter_rust_bridge::DartOpaque {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { flutter_rust_bridge::for_generated::sse_decode_dart_opaque(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<CustomDB>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CancellationToken>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConnectionId>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Cookie>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CustomBatch>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Keypair>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ListenerId>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessageId>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerId>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ResponseChannel<Vec<u8>>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for u128 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return inner.parse().unwrap();
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::api::p2p_pubsub::CustomMessageAcceptance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::p2p_pubsub::CustomMessageAcceptance::Reject,
            1 => crate::api::p2p_pubsub::CustomMessageAcceptance::Ignore,
            2 => crate::api::p2p_pubsub::CustomMessageAcceptance::Accept,
            _ => unreachable!("Invalid variant for CustomMessageAcceptance: {}", inner),
        };
    }
}

impl SseDecode for crate::api::p2p_common::CustomNatStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomNatStatus::Public(var_field0);
            }
            1 => {
                return crate::api::p2p_common::CustomNatStatus::Private;
            }
            2 => {
                return crate::api::p2p_common::CustomNatStatus::Unknown;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::p2p_common::CustomPeerRecord {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_peerId = <String>::sse_decode(deserializer);
        let mut var_addresses = <Vec<String>>::sse_decode(deserializer);
        return crate::api::p2p_common::CustomPeerRecord {
            peer_id: var_peerId,
            addresses: var_addresses,
        };
    }
}

impl SseDecode for crate::api::p2p_common::CustomSwarmEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::UpnpNewExternalAddr(var_field0);
            }
            1 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::UpnpExpiredExternalAddr(
                    var_field0,
                );
            }
            2 => {
                return crate::api::p2p_common::CustomSwarmEvent::UpnpGatewayNotFound;
            }
            3 => {
                return crate::api::p2p_common::CustomSwarmEvent::UpnpNonRoutableGateway;
            }
            4 => {
                let mut var_oldValue =
                    <crate::api::p2p_common::CustomNatStatus>::sse_decode(deserializer);
                let mut var_newValue =
                    <crate::api::p2p_common::CustomNatStatus>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::NATStatusChanged {
                    old_value: var_oldValue,
                    new_value: var_newValue,
                };
            }
            5 => {
                let mut var_requestId = <String>::sse_decode(deserializer);
                let mut var_peer = <String>::sse_decode(deserializer);
                let mut var_message = <Vec<u8>>::sse_decode(deserializer);
                let mut var_channel =
                    <RustAutoOpaqueNom<ResponseChannel<Vec<u8>>>>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::RequestMessage {
                    request_id: var_requestId,
                    peer: var_peer,
                    message: var_message,
                    channel: var_channel,
                };
            }
            6 => {
                let mut var_requestId = <String>::sse_decode(deserializer);
                let mut var_peer = <String>::sse_decode(deserializer);
                let mut var_message = <Vec<u8>>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::ResponseMessage {
                    request_id: var_requestId,
                    peer: var_peer,
                    message: var_message,
                };
            }
            7 => {
                let mut var_peer = <String>::sse_decode(deserializer);
                let mut var_requestId = <String>::sse_decode(deserializer);
                let mut var_error = <String>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::RequestOutboundFailure {
                    peer: var_peer,
                    request_id: var_requestId,
                    error: var_error,
                };
            }
            8 => {
                let mut var_peer = <String>::sse_decode(deserializer);
                let mut var_requestId = <String>::sse_decode(deserializer);
                let mut var_error = <String>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::RequestInboundFailure {
                    peer: var_peer,
                    request_id: var_requestId,
                    error: var_error,
                };
            }
            9 => {
                let mut var_peer = <String>::sse_decode(deserializer);
                let mut var_requestId = <String>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::ResponseSent {
                    peer: var_peer,
                    request_id: var_requestId,
                };
            }
            10 => {
                let mut var_rendezvousNode = <String>::sse_decode(deserializer);
                let mut var_registrations =
                    <Vec<crate::api::p2p_common::CustomPeerRecord>>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::RdvClientDiscovered {
                    rendezvous_node: var_rendezvousNode,
                    registrations: var_registrations,
                };
            }
            11 => {
                let mut var_rendezvousNode = <String>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::RdvClientDiscoveryFail {
                    rendezvous_node: var_rendezvousNode,
                };
            }
            12 => {
                let mut var_rendezvousNode = <String>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::RdvClientRegistered {
                    rendezvous_node: var_rendezvousNode,
                };
            }
            13 => {
                let mut var_rendezvousNode = <String>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::RdvClientRegisteredFailed {
                    rendezvous_node: var_rendezvousNode,
                };
            }
            14 => {
                let mut var_peerId = <String>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::RdvClientDiscoveryExpired {
                    peer_id: var_peerId,
                };
            }
            15 => {
                let mut var_peerid = <String>::sse_decode(deserializer);
                let mut var_addresses = <Vec<String>>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::RdvServerPeerRegistered {
                    peerid: var_peerid,
                    addresses: var_addresses,
                };
            }
            16 => {
                let mut var_peerid = <String>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::RdvServerPeerUnRegistered {
                    peerid: var_peerid,
                };
            }
            17 => {
                let mut var_peerid = <String>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::RdvServerPeerExpired {
                    peerid: var_peerid,
                };
            }
            18 => {
                let mut var_peerId = <String>::sse_decode(deserializer);
                let mut var_publicKey = <Vec<u8>>::sse_decode(deserializer);
                let mut var_protocolVersion = <String>::sse_decode(deserializer);
                let mut var_agentVersion = <String>::sse_decode(deserializer);
                let mut var_listenAddrs = <Vec<String>>::sse_decode(deserializer);
                let mut var_protocols = <Vec<String>>::sse_decode(deserializer);
                let mut var_observedAddr = <String>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::IdentifyReceived {
                    peer_id: var_peerId,
                    public_key: var_publicKey,
                    protocol_version: var_protocolVersion,
                    agent_version: var_agentVersion,
                    listen_addrs: var_listenAddrs,
                    protocols: var_protocols,
                    observed_addr: var_observedAddr,
                };
            }
            19 => {
                let mut var_propagationSource = <String>::sse_decode(deserializer);
                let mut var_messageId = <Vec<u8>>::sse_decode(deserializer);
                let mut var_message = <Vec<u8>>::sse_decode(deserializer);
                let mut var_source = <Option<String>>::sse_decode(deserializer);
                let mut var_topicHash = <String>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::GossipMessage {
                    propagation_source: var_propagationSource,
                    message_id: var_messageId,
                    message: var_message,
                    source: var_source,
                    topic_hash: var_topicHash,
                };
            }
            20 => {
                let mut var_peerId = <String>::sse_decode(deserializer);
                let mut var_topic = <String>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::GossipSubscribed {
                    peer_id: var_peerId,
                    topic: var_topic,
                };
            }
            21 => {
                let mut var_peerId = <String>::sse_decode(deserializer);
                let mut var_topic = <String>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::GossipUnsubscribed {
                    peer_id: var_peerId,
                    topic: var_topic,
                };
            }
            22 => {
                let mut var_peerId = <String>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::GossipsubNotSupported {
                    peer_id: var_peerId,
                };
            }
            23 => {
                let mut var_peerId = <String>::sse_decode(deserializer);
                let mut var_connectionId = <ConnectionId>::sse_decode(deserializer);
                let mut var_endpoint = <String>::sse_decode(deserializer);
                let mut var_numEstablished = <u32>::sse_decode(deserializer);
                let mut var_establishedIn = <u128>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::ConnectionEstablished {
                    peer_id: var_peerId,
                    connection_id: var_connectionId,
                    endpoint: var_endpoint,
                    num_established: var_numEstablished,
                    established_in: var_establishedIn,
                };
            }
            24 => {
                let mut var_peerId = <String>::sse_decode(deserializer);
                let mut var_connectionId = <ConnectionId>::sse_decode(deserializer);
                let mut var_endpoint = <String>::sse_decode(deserializer);
                let mut var_numEstablished = <u32>::sse_decode(deserializer);
                let mut var_cause = <Option<String>>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::ConnectionClosed {
                    peer_id: var_peerId,
                    connection_id: var_connectionId,
                    endpoint: var_endpoint,
                    num_established: var_numEstablished,
                    cause: var_cause,
                };
            }
            25 => {
                let mut var_connectionId = <ConnectionId>::sse_decode(deserializer);
                let mut var_localAddr = <String>::sse_decode(deserializer);
                let mut var_sendBackAddr = <String>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::IncomingConnection {
                    connection_id: var_connectionId,
                    local_addr: var_localAddr,
                    send_back_addr: var_sendBackAddr,
                };
            }
            26 => {
                let mut var_connectionId = <ConnectionId>::sse_decode(deserializer);
                let mut var_localAddr = <String>::sse_decode(deserializer);
                let mut var_sendBackAddr = <String>::sse_decode(deserializer);
                let mut var_error = <String>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::IncomingConnectionError {
                    connection_id: var_connectionId,
                    local_addr: var_localAddr,
                    send_back_addr: var_sendBackAddr,
                    error: var_error,
                };
            }
            27 => {
                let mut var_connectionId = <ConnectionId>::sse_decode(deserializer);
                let mut var_peerId = <Option<String>>::sse_decode(deserializer);
                let mut var_error = <String>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::OutgoingConnectionError {
                    connection_id: var_connectionId,
                    peer_id: var_peerId,
                    error: var_error,
                };
            }
            28 => {
                let mut var_listenerId = <String>::sse_decode(deserializer);
                let mut var_address = <String>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::NewListenAddr {
                    listener_id: var_listenerId,
                    address: var_address,
                };
            }
            29 => {
                let mut var_listenerId = <String>::sse_decode(deserializer);
                let mut var_address = <String>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::ExpiredListenAddr {
                    listener_id: var_listenerId,
                    address: var_address,
                };
            }
            30 => {
                let mut var_listenerId = <String>::sse_decode(deserializer);
                let mut var_addresses = <Vec<String>>::sse_decode(deserializer);
                let mut var_reason = <Option<String>>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::ListenerClosed {
                    listener_id: var_listenerId,
                    addresses: var_addresses,
                    reason: var_reason,
                };
            }
            31 => {
                let mut var_listenerId = <String>::sse_decode(deserializer);
                let mut var_error = <String>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::ListenerError {
                    listener_id: var_listenerId,
                    error: var_error,
                };
            }
            32 => {
                let mut var_peerId = <Option<String>>::sse_decode(deserializer);
                let mut var_connectionId = <ConnectionId>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::Dialing {
                    peer_id: var_peerId,
                    connection_id: var_connectionId,
                };
            }
            33 => {
                let mut var_address = <String>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::NewExternalAddrCandidate {
                    address: var_address,
                };
            }
            34 => {
                let mut var_address = <String>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::ExternalAddrConfirmed {
                    address: var_address,
                };
            }
            35 => {
                let mut var_address = <String>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::ExternalAddrExpired {
                    address: var_address,
                };
            }
            36 => {
                let mut var_peerId = <String>::sse_decode(deserializer);
                let mut var_address = <String>::sse_decode(deserializer);
                return crate::api::p2p_common::CustomSwarmEvent::NewExternalAddrOfPeer {
                    peer_id: var_peerId,
                    address: var_address,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::api::p2p_common::GenericError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::p2p_common::GenericError::InstanceNotFound;
            }
            1 => {
                return crate::api::p2p_common::GenericError::BadAddress;
            }
            2 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::p2p_common::GenericError::Other(var_field0);
            }
            3 => {
                let mut var_field0 = <Vec<u8>>::sse_decode(deserializer);
                return crate::api::p2p_common::GenericError::Bytes(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::api::p2p_key::KeyType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::p2p_key::KeyType::Ed25519,
            1 => crate::api::p2p_key::KeyType::Rsa,
            2 => crate::api::p2p_key::KeyType::Secp256k1,
            3 => crate::api::p2p_key::KeyType::Ecdsa,
            _ => unreachable!("Invalid variant for KeyType: {}", inner),
        };
    }
}

impl SseDecode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<String>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::p2p_common::CustomPeerRecord> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::p2p_common::CustomPeerRecord>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<Vec<u8>>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(Vec<u8>, Vec<u8>)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(Vec<u8>, Vec<u8>)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Cookie> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Cookie>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<(Vec<u8>, Vec<u8>)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<(Vec<u8>, Vec<u8>)>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<usize> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<usize>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<u8>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for (Vec<u8>, Vec<u8>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <Vec<u8>>::sse_decode(deserializer);
        let mut var_field1 = <Vec<u8>>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Arc<CustomDB>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Arc<CustomDB>> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Arc<CustomDB>>> for Arc<CustomDB> {
    fn into_into_dart(self) -> FrbWrapper<Arc<CustomDB>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Arc<Wrapper>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Arc<Wrapper>> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Arc<Wrapper>>> for Arc<Wrapper> {
    fn into_into_dart(self) -> FrbWrapper<Arc<Wrapper>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<CancellationToken> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<CancellationToken> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<CancellationToken>> for CancellationToken {
    fn into_into_dart(self) -> FrbWrapper<CancellationToken> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ConnectionId> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ConnectionId> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ConnectionId>> for ConnectionId {
    fn into_into_dart(self) -> FrbWrapper<ConnectionId> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Cookie> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Cookie> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Cookie>> for Cookie {
    fn into_into_dart(self) -> FrbWrapper<Cookie> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<CustomBatch> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<CustomBatch> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<CustomBatch>> for CustomBatch {
    fn into_into_dart(self) -> FrbWrapper<CustomBatch> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Keypair> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Keypair> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Keypair>> for Keypair {
    fn into_into_dart(self) -> FrbWrapper<Keypair> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ListenerId> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ListenerId> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ListenerId>> for ListenerId {
    fn into_into_dart(self) -> FrbWrapper<ListenerId> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<MessageId> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<MessageId> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<MessageId>> for MessageId {
    fn into_into_dart(self) -> FrbWrapper<MessageId> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<PeerId> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<PeerId> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<PeerId>> for PeerId {
    fn into_into_dart(self) -> FrbWrapper<PeerId> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<PublicKey> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<PublicKey> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<PublicKey>> for PublicKey {
    fn into_into_dart(self) -> FrbWrapper<PublicKey> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ResponseChannel<Vec<u8>>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ResponseChannel<Vec<u8>>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ResponseChannel<Vec<u8>>>>
    for ResponseChannel<Vec<u8>>
{
    fn into_into_dart(self) -> FrbWrapper<ResponseChannel<Vec<u8>>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::p2p_pubsub::CustomMessageAcceptance {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Reject => 0.into_dart(),
            Self::Ignore => 1.into_dart(),
            Self::Accept => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::p2p_pubsub::CustomMessageAcceptance
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::p2p_pubsub::CustomMessageAcceptance>
    for crate::api::p2p_pubsub::CustomMessageAcceptance
{
    fn into_into_dart(self) -> crate::api::p2p_pubsub::CustomMessageAcceptance {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::p2p_common::CustomNatStatus {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::p2p_common::CustomNatStatus::Public(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::p2p_common::CustomNatStatus::Private => [1.into_dart()].into_dart(),
            crate::api::p2p_common::CustomNatStatus::Unknown => [2.into_dart()].into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::p2p_common::CustomNatStatus
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::p2p_common::CustomNatStatus>
    for crate::api::p2p_common::CustomNatStatus
{
    fn into_into_dart(self) -> crate::api::p2p_common::CustomNatStatus {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::p2p_common::CustomPeerRecord {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.peer_id.into_into_dart().into_dart(),
            self.addresses.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::p2p_common::CustomPeerRecord
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::p2p_common::CustomPeerRecord>
    for crate::api::p2p_common::CustomPeerRecord
{
    fn into_into_dart(self) -> crate::api::p2p_common::CustomPeerRecord {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::p2p_common::CustomSwarmEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::p2p_common::CustomSwarmEvent::UpnpNewExternalAddr(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::p2p_common::CustomSwarmEvent::UpnpExpiredExternalAddr(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::p2p_common::CustomSwarmEvent::UpnpGatewayNotFound => {
                [2.into_dart()].into_dart()
            }
            crate::api::p2p_common::CustomSwarmEvent::UpnpNonRoutableGateway => {
                [3.into_dart()].into_dart()
            }
            crate::api::p2p_common::CustomSwarmEvent::NATStatusChanged {
                old_value,
                new_value,
            } => [
                4.into_dart(),
                old_value.into_into_dart().into_dart(),
                new_value.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::p2p_common::CustomSwarmEvent::RequestMessage {
                request_id,
                peer,
                message,
                channel,
            } => [
                5.into_dart(),
                request_id.into_into_dart().into_dart(),
                peer.into_into_dart().into_dart(),
                message.into_into_dart().into_dart(),
                channel.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::p2p_common::CustomSwarmEvent::ResponseMessage {
                request_id,
                peer,
                message,
            } => [
                6.into_dart(),
                request_id.into_into_dart().into_dart(),
                peer.into_into_dart().into_dart(),
                message.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::p2p_common::CustomSwarmEvent::RequestOutboundFailure {
                peer,
                request_id,
                error,
            } => [
                7.into_dart(),
                peer.into_into_dart().into_dart(),
                request_id.into_into_dart().into_dart(),
                error.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::p2p_common::CustomSwarmEvent::RequestInboundFailure {
                peer,
                request_id,
                error,
            } => [
                8.into_dart(),
                peer.into_into_dart().into_dart(),
                request_id.into_into_dart().into_dart(),
                error.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::p2p_common::CustomSwarmEvent::ResponseSent { peer, request_id } => [
                9.into_dart(),
                peer.into_into_dart().into_dart(),
                request_id.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::p2p_common::CustomSwarmEvent::RdvClientDiscovered {
                rendezvous_node,
                registrations,
            } => [
                10.into_dart(),
                rendezvous_node.into_into_dart().into_dart(),
                registrations.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::p2p_common::CustomSwarmEvent::RdvClientDiscoveryFail {
                rendezvous_node,
            } => [11.into_dart(), rendezvous_node.into_into_dart().into_dart()].into_dart(),
            crate::api::p2p_common::CustomSwarmEvent::RdvClientRegistered { rendezvous_node } => {
                [12.into_dart(), rendezvous_node.into_into_dart().into_dart()].into_dart()
            }
            crate::api::p2p_common::CustomSwarmEvent::RdvClientRegisteredFailed {
                rendezvous_node,
            } => [13.into_dart(), rendezvous_node.into_into_dart().into_dart()].into_dart(),
            crate::api::p2p_common::CustomSwarmEvent::RdvClientDiscoveryExpired { peer_id } => {
                [14.into_dart(), peer_id.into_into_dart().into_dart()].into_dart()
            }
            crate::api::p2p_common::CustomSwarmEvent::RdvServerPeerRegistered {
                peerid,
                addresses,
            } => [
                15.into_dart(),
                peerid.into_into_dart().into_dart(),
                addresses.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::p2p_common::CustomSwarmEvent::RdvServerPeerUnRegistered { peerid } => {
                [16.into_dart(), peerid.into_into_dart().into_dart()].into_dart()
            }
            crate::api::p2p_common::CustomSwarmEvent::RdvServerPeerExpired { peerid } => {
                [17.into_dart(), peerid.into_into_dart().into_dart()].into_dart()
            }
            crate::api::p2p_common::CustomSwarmEvent::IdentifyReceived {
                peer_id,
                public_key,
                protocol_version,
                agent_version,
                listen_addrs,
                protocols,
                observed_addr,
            } => [
                18.into_dart(),
                peer_id.into_into_dart().into_dart(),
                public_key.into_into_dart().into_dart(),
                protocol_version.into_into_dart().into_dart(),
                agent_version.into_into_dart().into_dart(),
                listen_addrs.into_into_dart().into_dart(),
                protocols.into_into_dart().into_dart(),
                observed_addr.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::p2p_common::CustomSwarmEvent::GossipMessage {
                propagation_source,
                message_id,
                message,
                source,
                topic_hash,
            } => [
                19.into_dart(),
                propagation_source.into_into_dart().into_dart(),
                message_id.into_into_dart().into_dart(),
                message.into_into_dart().into_dart(),
                source.into_into_dart().into_dart(),
                topic_hash.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::p2p_common::CustomSwarmEvent::GossipSubscribed { peer_id, topic } => [
                20.into_dart(),
                peer_id.into_into_dart().into_dart(),
                topic.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::p2p_common::CustomSwarmEvent::GossipUnsubscribed { peer_id, topic } => [
                21.into_dart(),
                peer_id.into_into_dart().into_dart(),
                topic.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::p2p_common::CustomSwarmEvent::GossipsubNotSupported { peer_id } => {
                [22.into_dart(), peer_id.into_into_dart().into_dart()].into_dart()
            }
            crate::api::p2p_common::CustomSwarmEvent::ConnectionEstablished {
                peer_id,
                connection_id,
                endpoint,
                num_established,
                established_in,
            } => [
                23.into_dart(),
                peer_id.into_into_dart().into_dart(),
                connection_id.into_into_dart().into_dart(),
                endpoint.into_into_dart().into_dart(),
                num_established.into_into_dart().into_dart(),
                established_in.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::p2p_common::CustomSwarmEvent::ConnectionClosed {
                peer_id,
                connection_id,
                endpoint,
                num_established,
                cause,
            } => [
                24.into_dart(),
                peer_id.into_into_dart().into_dart(),
                connection_id.into_into_dart().into_dart(),
                endpoint.into_into_dart().into_dart(),
                num_established.into_into_dart().into_dart(),
                cause.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::p2p_common::CustomSwarmEvent::IncomingConnection {
                connection_id,
                local_addr,
                send_back_addr,
            } => [
                25.into_dart(),
                connection_id.into_into_dart().into_dart(),
                local_addr.into_into_dart().into_dart(),
                send_back_addr.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::p2p_common::CustomSwarmEvent::IncomingConnectionError {
                connection_id,
                local_addr,
                send_back_addr,
                error,
            } => [
                26.into_dart(),
                connection_id.into_into_dart().into_dart(),
                local_addr.into_into_dart().into_dart(),
                send_back_addr.into_into_dart().into_dart(),
                error.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::p2p_common::CustomSwarmEvent::OutgoingConnectionError {
                connection_id,
                peer_id,
                error,
            } => [
                27.into_dart(),
                connection_id.into_into_dart().into_dart(),
                peer_id.into_into_dart().into_dart(),
                error.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::p2p_common::CustomSwarmEvent::NewListenAddr {
                listener_id,
                address,
            } => [
                28.into_dart(),
                listener_id.into_into_dart().into_dart(),
                address.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::p2p_common::CustomSwarmEvent::ExpiredListenAddr {
                listener_id,
                address,
            } => [
                29.into_dart(),
                listener_id.into_into_dart().into_dart(),
                address.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::p2p_common::CustomSwarmEvent::ListenerClosed {
                listener_id,
                addresses,
                reason,
            } => [
                30.into_dart(),
                listener_id.into_into_dart().into_dart(),
                addresses.into_into_dart().into_dart(),
                reason.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::p2p_common::CustomSwarmEvent::ListenerError { listener_id, error } => [
                31.into_dart(),
                listener_id.into_into_dart().into_dart(),
                error.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::p2p_common::CustomSwarmEvent::Dialing {
                peer_id,
                connection_id,
            } => [
                32.into_dart(),
                peer_id.into_into_dart().into_dart(),
                connection_id.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::p2p_common::CustomSwarmEvent::NewExternalAddrCandidate { address } => {
                [33.into_dart(), address.into_into_dart().into_dart()].into_dart()
            }
            crate::api::p2p_common::CustomSwarmEvent::ExternalAddrConfirmed { address } => {
                [34.into_dart(), address.into_into_dart().into_dart()].into_dart()
            }
            crate::api::p2p_common::CustomSwarmEvent::ExternalAddrExpired { address } => {
                [35.into_dart(), address.into_into_dart().into_dart()].into_dart()
            }
            crate::api::p2p_common::CustomSwarmEvent::NewExternalAddrOfPeer {
                peer_id,
                address,
            } => [
                36.into_dart(),
                peer_id.into_into_dart().into_dart(),
                address.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::p2p_common::CustomSwarmEvent
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::p2p_common::CustomSwarmEvent>
    for crate::api::p2p_common::CustomSwarmEvent
{
    fn into_into_dart(self) -> crate::api::p2p_common::CustomSwarmEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::p2p_common::GenericError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::p2p_common::GenericError::InstanceNotFound => [0.into_dart()].into_dart(),
            crate::api::p2p_common::GenericError::BadAddress => [1.into_dart()].into_dart(),
            crate::api::p2p_common::GenericError::Other(field0) => {
                [2.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::p2p_common::GenericError::Bytes(field0) => {
                [3.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::p2p_common::GenericError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::p2p_common::GenericError>
    for crate::api::p2p_common::GenericError
{
    fn into_into_dart(self) -> crate::api::p2p_common::GenericError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::p2p_key::KeyType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Ed25519 => 0.into_dart(),
            Self::Rsa => 1.into_dart(),
            Self::Secp256k1 => 2.into_dart(),
            Self::Ecdsa => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::p2p_key::KeyType {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::p2p_key::KeyType>
    for crate::api::p2p_key::KeyType
{
    fn into_into_dart(self) -> crate::api::p2p_key::KeyType {
        self
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode for RustAutoOpaqueNom<ResponseChannel<Vec<u8>>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ResponseChannel<Vec<u8>>>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_explicit_encode(self),
            serializer,
        );
    }
}

impl SseEncode for Arc<CustomDB> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < CustomDB >>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for Arc<Wrapper> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < Wrapper >>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for CancellationToken {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CancellationToken>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for ConnectionId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConnectionId>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for Cookie {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Cookie>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for CustomBatch {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CustomBatch>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for Keypair {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Keypair>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for ListenerId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ListenerId>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for MessageId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessageId>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for PeerId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerId>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for PublicKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for ResponseChannel<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ResponseChannel<Vec<u8>>>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for flutter_rust_bridge::DartOpaque {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.encode(), serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<CustomDB>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CancellationToken>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConnectionId>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Cookie>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CustomBatch>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Keypair>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ListenerId>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessageId>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerId>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ResponseChannel<Vec<u8>>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for u128 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.to_string(), serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::api::p2p_pubsub::CustomMessageAcceptance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::p2p_pubsub::CustomMessageAcceptance::Reject => 0,
                crate::api::p2p_pubsub::CustomMessageAcceptance::Ignore => 1,
                crate::api::p2p_pubsub::CustomMessageAcceptance::Accept => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::p2p_common::CustomNatStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::p2p_common::CustomNatStatus::Public(field0) => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::p2p_common::CustomNatStatus::Private => {
                <i32>::sse_encode(1, serializer);
            }
            crate::api::p2p_common::CustomNatStatus::Unknown => {
                <i32>::sse_encode(2, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::p2p_common::CustomPeerRecord {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.peer_id, serializer);
        <Vec<String>>::sse_encode(self.addresses, serializer);
    }
}

impl SseEncode for crate::api::p2p_common::CustomSwarmEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::p2p_common::CustomSwarmEvent::UpnpNewExternalAddr(field0) => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::UpnpExpiredExternalAddr(field0) => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::UpnpGatewayNotFound => {
                <i32>::sse_encode(2, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::UpnpNonRoutableGateway => {
                <i32>::sse_encode(3, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::NATStatusChanged {
                old_value,
                new_value,
            } => {
                <i32>::sse_encode(4, serializer);
                <crate::api::p2p_common::CustomNatStatus>::sse_encode(old_value, serializer);
                <crate::api::p2p_common::CustomNatStatus>::sse_encode(new_value, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::RequestMessage {
                request_id,
                peer,
                message,
                channel,
            } => {
                <i32>::sse_encode(5, serializer);
                <String>::sse_encode(request_id, serializer);
                <String>::sse_encode(peer, serializer);
                <Vec<u8>>::sse_encode(message, serializer);
                <RustAutoOpaqueNom<ResponseChannel<Vec<u8>>>>::sse_encode(channel, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::ResponseMessage {
                request_id,
                peer,
                message,
            } => {
                <i32>::sse_encode(6, serializer);
                <String>::sse_encode(request_id, serializer);
                <String>::sse_encode(peer, serializer);
                <Vec<u8>>::sse_encode(message, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::RequestOutboundFailure {
                peer,
                request_id,
                error,
            } => {
                <i32>::sse_encode(7, serializer);
                <String>::sse_encode(peer, serializer);
                <String>::sse_encode(request_id, serializer);
                <String>::sse_encode(error, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::RequestInboundFailure {
                peer,
                request_id,
                error,
            } => {
                <i32>::sse_encode(8, serializer);
                <String>::sse_encode(peer, serializer);
                <String>::sse_encode(request_id, serializer);
                <String>::sse_encode(error, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::ResponseSent { peer, request_id } => {
                <i32>::sse_encode(9, serializer);
                <String>::sse_encode(peer, serializer);
                <String>::sse_encode(request_id, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::RdvClientDiscovered {
                rendezvous_node,
                registrations,
            } => {
                <i32>::sse_encode(10, serializer);
                <String>::sse_encode(rendezvous_node, serializer);
                <Vec<crate::api::p2p_common::CustomPeerRecord>>::sse_encode(
                    registrations,
                    serializer,
                );
            }
            crate::api::p2p_common::CustomSwarmEvent::RdvClientDiscoveryFail {
                rendezvous_node,
            } => {
                <i32>::sse_encode(11, serializer);
                <String>::sse_encode(rendezvous_node, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::RdvClientRegistered { rendezvous_node } => {
                <i32>::sse_encode(12, serializer);
                <String>::sse_encode(rendezvous_node, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::RdvClientRegisteredFailed {
                rendezvous_node,
            } => {
                <i32>::sse_encode(13, serializer);
                <String>::sse_encode(rendezvous_node, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::RdvClientDiscoveryExpired { peer_id } => {
                <i32>::sse_encode(14, serializer);
                <String>::sse_encode(peer_id, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::RdvServerPeerRegistered {
                peerid,
                addresses,
            } => {
                <i32>::sse_encode(15, serializer);
                <String>::sse_encode(peerid, serializer);
                <Vec<String>>::sse_encode(addresses, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::RdvServerPeerUnRegistered { peerid } => {
                <i32>::sse_encode(16, serializer);
                <String>::sse_encode(peerid, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::RdvServerPeerExpired { peerid } => {
                <i32>::sse_encode(17, serializer);
                <String>::sse_encode(peerid, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::IdentifyReceived {
                peer_id,
                public_key,
                protocol_version,
                agent_version,
                listen_addrs,
                protocols,
                observed_addr,
            } => {
                <i32>::sse_encode(18, serializer);
                <String>::sse_encode(peer_id, serializer);
                <Vec<u8>>::sse_encode(public_key, serializer);
                <String>::sse_encode(protocol_version, serializer);
                <String>::sse_encode(agent_version, serializer);
                <Vec<String>>::sse_encode(listen_addrs, serializer);
                <Vec<String>>::sse_encode(protocols, serializer);
                <String>::sse_encode(observed_addr, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::GossipMessage {
                propagation_source,
                message_id,
                message,
                source,
                topic_hash,
            } => {
                <i32>::sse_encode(19, serializer);
                <String>::sse_encode(propagation_source, serializer);
                <Vec<u8>>::sse_encode(message_id, serializer);
                <Vec<u8>>::sse_encode(message, serializer);
                <Option<String>>::sse_encode(source, serializer);
                <String>::sse_encode(topic_hash, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::GossipSubscribed { peer_id, topic } => {
                <i32>::sse_encode(20, serializer);
                <String>::sse_encode(peer_id, serializer);
                <String>::sse_encode(topic, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::GossipUnsubscribed { peer_id, topic } => {
                <i32>::sse_encode(21, serializer);
                <String>::sse_encode(peer_id, serializer);
                <String>::sse_encode(topic, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::GossipsubNotSupported { peer_id } => {
                <i32>::sse_encode(22, serializer);
                <String>::sse_encode(peer_id, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::ConnectionEstablished {
                peer_id,
                connection_id,
                endpoint,
                num_established,
                established_in,
            } => {
                <i32>::sse_encode(23, serializer);
                <String>::sse_encode(peer_id, serializer);
                <ConnectionId>::sse_encode(connection_id, serializer);
                <String>::sse_encode(endpoint, serializer);
                <u32>::sse_encode(num_established, serializer);
                <u128>::sse_encode(established_in, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::ConnectionClosed {
                peer_id,
                connection_id,
                endpoint,
                num_established,
                cause,
            } => {
                <i32>::sse_encode(24, serializer);
                <String>::sse_encode(peer_id, serializer);
                <ConnectionId>::sse_encode(connection_id, serializer);
                <String>::sse_encode(endpoint, serializer);
                <u32>::sse_encode(num_established, serializer);
                <Option<String>>::sse_encode(cause, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::IncomingConnection {
                connection_id,
                local_addr,
                send_back_addr,
            } => {
                <i32>::sse_encode(25, serializer);
                <ConnectionId>::sse_encode(connection_id, serializer);
                <String>::sse_encode(local_addr, serializer);
                <String>::sse_encode(send_back_addr, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::IncomingConnectionError {
                connection_id,
                local_addr,
                send_back_addr,
                error,
            } => {
                <i32>::sse_encode(26, serializer);
                <ConnectionId>::sse_encode(connection_id, serializer);
                <String>::sse_encode(local_addr, serializer);
                <String>::sse_encode(send_back_addr, serializer);
                <String>::sse_encode(error, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::OutgoingConnectionError {
                connection_id,
                peer_id,
                error,
            } => {
                <i32>::sse_encode(27, serializer);
                <ConnectionId>::sse_encode(connection_id, serializer);
                <Option<String>>::sse_encode(peer_id, serializer);
                <String>::sse_encode(error, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::NewListenAddr {
                listener_id,
                address,
            } => {
                <i32>::sse_encode(28, serializer);
                <String>::sse_encode(listener_id, serializer);
                <String>::sse_encode(address, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::ExpiredListenAddr {
                listener_id,
                address,
            } => {
                <i32>::sse_encode(29, serializer);
                <String>::sse_encode(listener_id, serializer);
                <String>::sse_encode(address, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::ListenerClosed {
                listener_id,
                addresses,
                reason,
            } => {
                <i32>::sse_encode(30, serializer);
                <String>::sse_encode(listener_id, serializer);
                <Vec<String>>::sse_encode(addresses, serializer);
                <Option<String>>::sse_encode(reason, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::ListenerError { listener_id, error } => {
                <i32>::sse_encode(31, serializer);
                <String>::sse_encode(listener_id, serializer);
                <String>::sse_encode(error, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::Dialing {
                peer_id,
                connection_id,
            } => {
                <i32>::sse_encode(32, serializer);
                <Option<String>>::sse_encode(peer_id, serializer);
                <ConnectionId>::sse_encode(connection_id, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::NewExternalAddrCandidate { address } => {
                <i32>::sse_encode(33, serializer);
                <String>::sse_encode(address, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::ExternalAddrConfirmed { address } => {
                <i32>::sse_encode(34, serializer);
                <String>::sse_encode(address, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::ExternalAddrExpired { address } => {
                <i32>::sse_encode(35, serializer);
                <String>::sse_encode(address, serializer);
            }
            crate::api::p2p_common::CustomSwarmEvent::NewExternalAddrOfPeer {
                peer_id,
                address,
            } => {
                <i32>::sse_encode(36, serializer);
                <String>::sse_encode(peer_id, serializer);
                <String>::sse_encode(address, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::api::p2p_common::GenericError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::p2p_common::GenericError::InstanceNotFound => {
                <i32>::sse_encode(0, serializer);
            }
            crate::api::p2p_common::GenericError::BadAddress => {
                <i32>::sse_encode(1, serializer);
            }
            crate::api::p2p_common::GenericError::Other(field0) => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::p2p_common::GenericError::Bytes(field0) => {
                <i32>::sse_encode(3, serializer);
                <Vec<u8>>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::api::p2p_key::KeyType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::p2p_key::KeyType::Ed25519 => 0,
                crate::api::p2p_key::KeyType::Rsa => 1,
                crate::api::p2p_key::KeyType::Secp256k1 => 2,
                crate::api::p2p_key::KeyType::Ecdsa => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <String>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::p2p_common::CustomPeerRecord> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::p2p_common::CustomPeerRecord>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <Vec<u8>>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(Vec<u8>, Vec<u8>)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(Vec<u8>, Vec<u8>)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Cookie> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Cookie>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<(Vec<u8>, Vec<u8>)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <(Vec<u8>, Vec<u8>)>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<usize> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <usize>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<u8>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for (Vec<u8>, Vec<u8>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.0, serializer);
        <Vec<u8>>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // Generated by `flutter_rust_bridge`@ 2.2.0.

    // Section: imports

    use super::*;
    use crate::api::p2p_common::*;
    use crate::api::p2p_dial::*;
    use crate::api::p2p_event::*;
    use crate::api::p2p_key::*;
    use crate::api::p2p_rdv::*;
    use crate::api::p2p_utils::*;
    use crate::api::sled::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();

    // Section: dart2rust

    impl CstDecode<flutter_rust_bridge::for_generated::anyhow::Error>
        for *mut wire_cst_list_prim_u_8_strict
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> flutter_rust_bridge::for_generated::anyhow::Error {
            unimplemented!()
        }
    }
    impl CstDecode<RustAutoOpaqueNom<ResponseChannel<Vec<u8>>>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustAutoOpaqueNom<ResponseChannel<Vec<u8>>> {
            flutter_rust_bridge::for_generated::rust_auto_opaque_explicit_decode(self.cst_decode())
        }
    }
    impl CstDecode<Arc<CustomDB>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Arc<CustomDB> {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<CustomDB>>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<Arc<Wrapper>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Arc<Wrapper> {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<CancellationToken> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> CancellationToken {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CancellationToken>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<ConnectionId> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ConnectionId {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConnectionId>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<Cookie> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Cookie {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Cookie>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<CustomBatch> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> CustomBatch {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CustomBatch>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<Keypair> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Keypair {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Keypair>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<ListenerId> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ListenerId {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ListenerId>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<MessageId> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> MessageId {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessageId>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<PeerId> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> PeerId {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerId>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<PublicKey> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> PublicKey {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<ResponseChannel<Vec<u8>>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ResponseChannel<Vec<u8>> {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                        ResponseChannel<Vec<u8>>,
                    >,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<flutter_rust_bridge::DartOpaque> for *const std::ffi::c_void {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> flutter_rust_bridge::DartOpaque {
            unsafe { flutter_rust_bridge::for_generated::cst_decode_dart_opaque(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<CustomDB>>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<CustomDB>>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CancellationToken>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CancellationToken>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConnectionId>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConnectionId>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Cookie>>>
        for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Cookie>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CustomBatch>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CustomBatch>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Keypair>>>
        for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Keypair>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ListenerId>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ListenerId>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessageId>>>
        for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessageId>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerId>>>
        for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerId>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>>
        for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ResponseChannel<Vec<u8>>>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ResponseChannel<Vec<u8>>>,
        > {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<String> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> String {
            let vec: Vec<u8> = self.cst_decode();
            String::from_utf8(vec).unwrap()
        }
    }
    impl CstDecode<u128> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u128 {
            CstDecode::<String>::cst_decode(self).parse().unwrap()
        }
    }
    impl CstDecode<Cookie> for *mut usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Cookie {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<Cookie>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::p2p_common::CustomNatStatus> for *mut wire_cst_custom_nat_status {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::p2p_common::CustomNatStatus {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::p2p_common::CustomNatStatus>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::p2p_common::CustomSwarmEvent> for *mut wire_cst_custom_swarm_event {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::p2p_common::CustomSwarmEvent {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::p2p_common::CustomSwarmEvent>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<(Vec<u8>, Vec<u8>)>
        for *mut wire_cst_record_list_prim_u_8_strict_list_prim_u_8_strict
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> (Vec<u8>, Vec<u8>) {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<(Vec<u8>, Vec<u8>)>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<u32> for *mut u32 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u32 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<u64> for *mut u64 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u64 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<usize> for *mut usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> usize {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<crate::api::p2p_common::CustomNatStatus> for wire_cst_custom_nat_status {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::p2p_common::CustomNatStatus {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.Public };
                    crate::api::p2p_common::CustomNatStatus::Public(ans.field0.cst_decode())
                }
                1 => crate::api::p2p_common::CustomNatStatus::Private,
                2 => crate::api::p2p_common::CustomNatStatus::Unknown,
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::p2p_common::CustomPeerRecord> for wire_cst_custom_peer_record {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::p2p_common::CustomPeerRecord {
            crate::api::p2p_common::CustomPeerRecord {
                peer_id: self.peer_id.cst_decode(),
                addresses: self.addresses.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::p2p_common::CustomSwarmEvent> for wire_cst_custom_swarm_event {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::p2p_common::CustomSwarmEvent {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.UpnpNewExternalAddr };
                    crate::api::p2p_common::CustomSwarmEvent::UpnpNewExternalAddr(
                        ans.field0.cst_decode(),
                    )
                }
                1 => {
                    let ans = unsafe { self.kind.UpnpExpiredExternalAddr };
                    crate::api::p2p_common::CustomSwarmEvent::UpnpExpiredExternalAddr(
                        ans.field0.cst_decode(),
                    )
                }
                2 => crate::api::p2p_common::CustomSwarmEvent::UpnpGatewayNotFound,
                3 => crate::api::p2p_common::CustomSwarmEvent::UpnpNonRoutableGateway,
                4 => {
                    let ans = unsafe { self.kind.NATStatusChanged };
                    crate::api::p2p_common::CustomSwarmEvent::NATStatusChanged {
                        old_value: ans.old_value.cst_decode(),
                        new_value: ans.new_value.cst_decode(),
                    }
                }
                5 => {
                    let ans = unsafe { self.kind.RequestMessage };
                    crate::api::p2p_common::CustomSwarmEvent::RequestMessage {
                        request_id: ans.request_id.cst_decode(),
                        peer: ans.peer.cst_decode(),
                        message: ans.message.cst_decode(),
                        channel: ans.channel.cst_decode(),
                    }
                }
                6 => {
                    let ans = unsafe { self.kind.ResponseMessage };
                    crate::api::p2p_common::CustomSwarmEvent::ResponseMessage {
                        request_id: ans.request_id.cst_decode(),
                        peer: ans.peer.cst_decode(),
                        message: ans.message.cst_decode(),
                    }
                }
                7 => {
                    let ans = unsafe { self.kind.RequestOutboundFailure };
                    crate::api::p2p_common::CustomSwarmEvent::RequestOutboundFailure {
                        peer: ans.peer.cst_decode(),
                        request_id: ans.request_id.cst_decode(),
                        error: ans.error.cst_decode(),
                    }
                }
                8 => {
                    let ans = unsafe { self.kind.RequestInboundFailure };
                    crate::api::p2p_common::CustomSwarmEvent::RequestInboundFailure {
                        peer: ans.peer.cst_decode(),
                        request_id: ans.request_id.cst_decode(),
                        error: ans.error.cst_decode(),
                    }
                }
                9 => {
                    let ans = unsafe { self.kind.ResponseSent };
                    crate::api::p2p_common::CustomSwarmEvent::ResponseSent {
                        peer: ans.peer.cst_decode(),
                        request_id: ans.request_id.cst_decode(),
                    }
                }
                10 => {
                    let ans = unsafe { self.kind.RdvClientDiscovered };
                    crate::api::p2p_common::CustomSwarmEvent::RdvClientDiscovered {
                        rendezvous_node: ans.rendezvous_node.cst_decode(),
                        registrations: ans.registrations.cst_decode(),
                    }
                }
                11 => {
                    let ans = unsafe { self.kind.RdvClientDiscoveryFail };
                    crate::api::p2p_common::CustomSwarmEvent::RdvClientDiscoveryFail {
                        rendezvous_node: ans.rendezvous_node.cst_decode(),
                    }
                }
                12 => {
                    let ans = unsafe { self.kind.RdvClientRegistered };
                    crate::api::p2p_common::CustomSwarmEvent::RdvClientRegistered {
                        rendezvous_node: ans.rendezvous_node.cst_decode(),
                    }
                }
                13 => {
                    let ans = unsafe { self.kind.RdvClientRegisteredFailed };
                    crate::api::p2p_common::CustomSwarmEvent::RdvClientRegisteredFailed {
                        rendezvous_node: ans.rendezvous_node.cst_decode(),
                    }
                }
                14 => {
                    let ans = unsafe { self.kind.RdvClientDiscoveryExpired };
                    crate::api::p2p_common::CustomSwarmEvent::RdvClientDiscoveryExpired {
                        peer_id: ans.peer_id.cst_decode(),
                    }
                }
                15 => {
                    let ans = unsafe { self.kind.RdvServerPeerRegistered };
                    crate::api::p2p_common::CustomSwarmEvent::RdvServerPeerRegistered {
                        peerid: ans.peerid.cst_decode(),
                        addresses: ans.addresses.cst_decode(),
                    }
                }
                16 => {
                    let ans = unsafe { self.kind.RdvServerPeerUnRegistered };
                    crate::api::p2p_common::CustomSwarmEvent::RdvServerPeerUnRegistered {
                        peerid: ans.peerid.cst_decode(),
                    }
                }
                17 => {
                    let ans = unsafe { self.kind.RdvServerPeerExpired };
                    crate::api::p2p_common::CustomSwarmEvent::RdvServerPeerExpired {
                        peerid: ans.peerid.cst_decode(),
                    }
                }
                18 => {
                    let ans = unsafe { self.kind.IdentifyReceived };
                    crate::api::p2p_common::CustomSwarmEvent::IdentifyReceived {
                        peer_id: ans.peer_id.cst_decode(),
                        public_key: ans.public_key.cst_decode(),
                        protocol_version: ans.protocol_version.cst_decode(),
                        agent_version: ans.agent_version.cst_decode(),
                        listen_addrs: ans.listen_addrs.cst_decode(),
                        protocols: ans.protocols.cst_decode(),
                        observed_addr: ans.observed_addr.cst_decode(),
                    }
                }
                19 => {
                    let ans = unsafe { self.kind.GossipMessage };
                    crate::api::p2p_common::CustomSwarmEvent::GossipMessage {
                        propagation_source: ans.propagation_source.cst_decode(),
                        message_id: ans.message_id.cst_decode(),
                        message: ans.message.cst_decode(),
                        source: ans.source.cst_decode(),
                        topic_hash: ans.topic_hash.cst_decode(),
                    }
                }
                20 => {
                    let ans = unsafe { self.kind.GossipSubscribed };
                    crate::api::p2p_common::CustomSwarmEvent::GossipSubscribed {
                        peer_id: ans.peer_id.cst_decode(),
                        topic: ans.topic.cst_decode(),
                    }
                }
                21 => {
                    let ans = unsafe { self.kind.GossipUnsubscribed };
                    crate::api::p2p_common::CustomSwarmEvent::GossipUnsubscribed {
                        peer_id: ans.peer_id.cst_decode(),
                        topic: ans.topic.cst_decode(),
                    }
                }
                22 => {
                    let ans = unsafe { self.kind.GossipsubNotSupported };
                    crate::api::p2p_common::CustomSwarmEvent::GossipsubNotSupported {
                        peer_id: ans.peer_id.cst_decode(),
                    }
                }
                23 => {
                    let ans = unsafe { self.kind.ConnectionEstablished };
                    crate::api::p2p_common::CustomSwarmEvent::ConnectionEstablished {
                        peer_id: ans.peer_id.cst_decode(),
                        connection_id: ans.connection_id.cst_decode(),
                        endpoint: ans.endpoint.cst_decode(),
                        num_established: ans.num_established.cst_decode(),
                        established_in: ans.established_in.cst_decode(),
                    }
                }
                24 => {
                    let ans = unsafe { self.kind.ConnectionClosed };
                    crate::api::p2p_common::CustomSwarmEvent::ConnectionClosed {
                        peer_id: ans.peer_id.cst_decode(),
                        connection_id: ans.connection_id.cst_decode(),
                        endpoint: ans.endpoint.cst_decode(),
                        num_established: ans.num_established.cst_decode(),
                        cause: ans.cause.cst_decode(),
                    }
                }
                25 => {
                    let ans = unsafe { self.kind.IncomingConnection };
                    crate::api::p2p_common::CustomSwarmEvent::IncomingConnection {
                        connection_id: ans.connection_id.cst_decode(),
                        local_addr: ans.local_addr.cst_decode(),
                        send_back_addr: ans.send_back_addr.cst_decode(),
                    }
                }
                26 => {
                    let ans = unsafe { self.kind.IncomingConnectionError };
                    crate::api::p2p_common::CustomSwarmEvent::IncomingConnectionError {
                        connection_id: ans.connection_id.cst_decode(),
                        local_addr: ans.local_addr.cst_decode(),
                        send_back_addr: ans.send_back_addr.cst_decode(),
                        error: ans.error.cst_decode(),
                    }
                }
                27 => {
                    let ans = unsafe { self.kind.OutgoingConnectionError };
                    crate::api::p2p_common::CustomSwarmEvent::OutgoingConnectionError {
                        connection_id: ans.connection_id.cst_decode(),
                        peer_id: ans.peer_id.cst_decode(),
                        error: ans.error.cst_decode(),
                    }
                }
                28 => {
                    let ans = unsafe { self.kind.NewListenAddr };
                    crate::api::p2p_common::CustomSwarmEvent::NewListenAddr {
                        listener_id: ans.listener_id.cst_decode(),
                        address: ans.address.cst_decode(),
                    }
                }
                29 => {
                    let ans = unsafe { self.kind.ExpiredListenAddr };
                    crate::api::p2p_common::CustomSwarmEvent::ExpiredListenAddr {
                        listener_id: ans.listener_id.cst_decode(),
                        address: ans.address.cst_decode(),
                    }
                }
                30 => {
                    let ans = unsafe { self.kind.ListenerClosed };
                    crate::api::p2p_common::CustomSwarmEvent::ListenerClosed {
                        listener_id: ans.listener_id.cst_decode(),
                        addresses: ans.addresses.cst_decode(),
                        reason: ans.reason.cst_decode(),
                    }
                }
                31 => {
                    let ans = unsafe { self.kind.ListenerError };
                    crate::api::p2p_common::CustomSwarmEvent::ListenerError {
                        listener_id: ans.listener_id.cst_decode(),
                        error: ans.error.cst_decode(),
                    }
                }
                32 => {
                    let ans = unsafe { self.kind.Dialing };
                    crate::api::p2p_common::CustomSwarmEvent::Dialing {
                        peer_id: ans.peer_id.cst_decode(),
                        connection_id: ans.connection_id.cst_decode(),
                    }
                }
                33 => {
                    let ans = unsafe { self.kind.NewExternalAddrCandidate };
                    crate::api::p2p_common::CustomSwarmEvent::NewExternalAddrCandidate {
                        address: ans.address.cst_decode(),
                    }
                }
                34 => {
                    let ans = unsafe { self.kind.ExternalAddrConfirmed };
                    crate::api::p2p_common::CustomSwarmEvent::ExternalAddrConfirmed {
                        address: ans.address.cst_decode(),
                    }
                }
                35 => {
                    let ans = unsafe { self.kind.ExternalAddrExpired };
                    crate::api::p2p_common::CustomSwarmEvent::ExternalAddrExpired {
                        address: ans.address.cst_decode(),
                    }
                }
                36 => {
                    let ans = unsafe { self.kind.NewExternalAddrOfPeer };
                    crate::api::p2p_common::CustomSwarmEvent::NewExternalAddrOfPeer {
                        peer_id: ans.peer_id.cst_decode(),
                        address: ans.address.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::p2p_common::GenericError> for wire_cst_generic_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::p2p_common::GenericError {
            match self.tag {
                0 => crate::api::p2p_common::GenericError::InstanceNotFound,
                1 => crate::api::p2p_common::GenericError::BadAddress,
                2 => {
                    let ans = unsafe { self.kind.Other };
                    crate::api::p2p_common::GenericError::Other(ans.field0.cst_decode())
                }
                3 => {
                    let ans = unsafe { self.kind.Bytes };
                    crate::api::p2p_common::GenericError::Bytes(ans.field0.cst_decode())
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<Vec<String>> for *mut wire_cst_list_String {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<String> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::api::p2p_common::CustomPeerRecord>>
        for *mut wire_cst_list_custom_peer_record
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::p2p_common::CustomPeerRecord> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<Vec<u8>>> for *mut wire_cst_list_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<Vec<u8>> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<u8>> for *mut wire_cst_list_prim_u_8_loose {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<u8>> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<(Vec<u8>, Vec<u8>)>>
        for *mut wire_cst_list_record_list_prim_u_8_strict_list_prim_u_8_strict
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<(Vec<u8>, Vec<u8>)> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<(Vec<u8>, Vec<u8>)> for wire_cst_record_list_prim_u_8_strict_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> (Vec<u8>, Vec<u8>) {
            (self.field0.cst_decode(), self.field1.cst_decode())
        }
    }
    impl NewWithNullPtr for wire_cst_custom_nat_status {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: CustomNatStatusKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_custom_nat_status {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_custom_peer_record {
        fn new_with_null_ptr() -> Self {
            Self {
                peer_id: core::ptr::null_mut(),
                addresses: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_custom_peer_record {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_custom_swarm_event {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: CustomSwarmEventKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_custom_swarm_event {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_generic_error {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: GenericErrorKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_generic_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_record_list_prim_u_8_strict_list_prim_u_8_strict {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: core::ptr::null_mut(),
                field1: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_record_list_prim_u_8_strict_list_prim_u_8_strict {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__minimal__init_app(port_: i64) {
        wire__crate__api__minimal__init_app_impl(port_)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_common__ConnectionId_to_string(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_common__ConnectionId_to_string_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_common__ListenerId_to_string(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_common__ListenerId_to_string_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_common__MessageId_to_string(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_common__MessageId_to_string_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_dial__libp2p_connected_peers(
        port_: i64,
        wrapper: usize,
    ) {
        wire__crate__api__p2p_dial__libp2p_connected_peers_impl(port_, wrapper)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_dial__libp2p_connected_peers_count(
        port_: i64,
        wrapper: usize,
    ) {
        wire__crate__api__p2p_dial__libp2p_connected_peers_count_impl(port_, wrapper)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_dial__libp2p_dial_address(
        port_: i64,
        wrapper: usize,
        address: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__p2p_dial__libp2p_dial_address_impl(port_, wrapper, address)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_dial__libp2p_dial_peer(
        port_: i64,
        wrapper: usize,
        peerid: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__p2p_dial__libp2p_dial_peer_impl(port_, wrapper, peerid)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_dial__libp2p_disconnect_peer(
        port_: i64,
        wrapper: usize,
        peerid: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__p2p_dial__libp2p_disconnect_peer_impl(port_, wrapper, peerid)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_dial__libp2p_isconnected(
        port_: i64,
        wrapper: usize,
        peer: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__p2p_dial__libp2p_isconnected_impl(port_, wrapper, peer)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_event__libp2p_add_event_listener(
        port_: i64,
        wrapper: usize,
        cancellation_token: usize,
        callback: *const std::ffi::c_void,
    ) {
        wire__crate__api__p2p_event__libp2p_add_event_listener_impl(
            port_,
            wrapper,
            cancellation_token,
            callback,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_event__libp2p_get_event_name(
        event: *mut wire_cst_custom_swarm_event,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_event__libp2p_get_event_name_impl(event)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_factory__create_libp2p_instance(
        port_: i64,
        keypair: usize,
        tcp_nodelay: bool,
        tcp_reuse_port: bool,
        pubsub_heartbeat_delay: u64,
        pubsub_heartbeat_interval: u64,
        nat_boot_delay: u64,
        nat_retry_interval: u64,
        nat_only_global_ips: bool,
        nat_use_connected: bool,
        connection_max_inout: *mut u32,
        connection_max_inbound: *mut u32,
        connection_max_outgoing: *mut u32,
        connection_max_pending_inbound: *mut u32,
        connection_max_pending_outgoing: *mut u32,
        memory_max_percentage: f64,
    ) {
        wire__crate__api__p2p_factory__create_libp2p_instance_impl(
            port_,
            keypair,
            tcp_nodelay,
            tcp_reuse_port,
            pubsub_heartbeat_delay,
            pubsub_heartbeat_interval,
            nat_boot_delay,
            nat_retry_interval,
            nat_only_global_ips,
            nat_use_connected,
            connection_max_inout,
            connection_max_inbound,
            connection_max_outgoing,
            connection_max_pending_inbound,
            connection_max_pending_outgoing,
            memory_max_percentage,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_key__Keypair_public(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_key__Keypair_public_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_key__PeerId_to_base58(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_key__PeerId_to_base58_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_key__PeerId_to_bytes(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_key__PeerId_to_bytes_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_key__PublicKey_encode_protobuf(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_key__PublicKey_encode_protobuf_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_key__PublicKey_to_peer_id(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_key__PublicKey_to_peer_id_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_key__create_keypair_from_bytes(
        port_: i64,
        key_type: i32,
        bytes: *mut wire_cst_list_prim_u_8_loose,
    ) {
        wire__crate__api__p2p_key__create_keypair_from_bytes_impl(port_, key_type, bytes)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_key__create_keypair_using_random(
        port_: i64,
        key_type: i32,
    ) {
        wire__crate__api__p2p_key__create_keypair_using_random_impl(port_, key_type)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_key__keypair_from_protobuf(
        proto: *mut wire_cst_list_prim_u_8_loose,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_key__keypair_from_protobuf_impl(proto)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_key__keypair_sign(
        port_: i64,
        keypair: usize,
        msg: *mut wire_cst_list_prim_u_8_loose,
    ) {
        wire__crate__api__p2p_key__keypair_sign_impl(port_, keypair, msg)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_key__keypair_to_protobuf(
        keypair: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_key__keypair_to_protobuf_impl(keypair)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_key__keypair_verify(
        port_: i64,
        key: usize,
        msg: *mut wire_cst_list_prim_u_8_loose,
        sig: *mut wire_cst_list_prim_u_8_loose,
    ) {
        wire__crate__api__p2p_key__keypair_verify_impl(port_, key, msg, sig)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_listen__libp2p_listen(
        port_: i64,
        wrapper: usize,
        address: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__p2p_listen__libp2p_listen_impl(port_, wrapper, address)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_listen__libp2p_unlisten(
        port_: i64,
        wrapper: usize,
        listener_id: usize,
    ) {
        wire__crate__api__p2p_listen__libp2p_unlisten_impl(port_, wrapper, listener_id)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_nat__libp2p_autonat_add_server(
        port_: i64,
        wrapper: usize,
        peer: *mut wire_cst_list_prim_u_8_strict,
        address: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__p2p_nat__libp2p_autonat_add_server_impl(port_, wrapper, peer, address)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_nat__libp2p_autonat_status(
        port_: i64,
        wrapper: usize,
    ) {
        wire__crate__api__p2p_nat__libp2p_autonat_status_impl(port_, wrapper)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_pubsub__libp2p_publish(
        port_: i64,
        wrapper: usize,
        topic: *mut wire_cst_list_prim_u_8_strict,
        data: *mut wire_cst_list_prim_u_8_loose,
    ) {
        wire__crate__api__p2p_pubsub__libp2p_publish_impl(port_, wrapper, topic, data)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_pubsub__libp2p_pubsub_add_peer(
        port_: i64,
        wrapper: usize,
        peer: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__p2p_pubsub__libp2p_pubsub_add_peer_impl(port_, wrapper, peer)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_pubsub__libp2p_pubsub_remove_peer(
        port_: i64,
        wrapper: usize,
        peer: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__p2p_pubsub__libp2p_pubsub_remove_peer_impl(port_, wrapper, peer)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_pubsub__libp2p_pubsub_validate(
        port_: i64,
        wrapper: usize,
        msg_id: *mut wire_cst_list_prim_u_8_loose,
        propagation_source: *mut wire_cst_list_prim_u_8_strict,
        acceptance: i32,
    ) {
        wire__crate__api__p2p_pubsub__libp2p_pubsub_validate_impl(
            port_,
            wrapper,
            msg_id,
            propagation_source,
            acceptance,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_pubsub__libp2p_subscribe(
        port_: i64,
        wrapper: usize,
        topic: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__p2p_pubsub__libp2p_subscribe_impl(port_, wrapper, topic)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_pubsub__libp2p_topic_tohash(
        topic: *mut wire_cst_list_prim_u_8_strict,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_pubsub__libp2p_topic_tohash_impl(topic)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_pubsub__libp2p_unsubscribe(
        port_: i64,
        wrapper: usize,
        topic: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__p2p_pubsub__libp2p_unsubscribe_impl(port_, wrapper, topic)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_rdv__Cookie_clone(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_rdv__Cookie_clone_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_rdv__libp2p_rdv_cookie(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_rdv__libp2p_rdv_cookie_impl()
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_rdv__libp2p_rdv_discover(
        port_: i64,
        wrapper: usize,
        rdv_peerid: *mut wire_cst_list_prim_u_8_strict,
        limit: *mut u64,
        cookie: *mut usize,
    ) {
        wire__crate__api__p2p_rdv__libp2p_rdv_discover_impl(
            port_, wrapper, rdv_peerid, limit, cookie,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_rdv__libp2p_rdv_register(
        port_: i64,
        wrapper: usize,
        rdv_peerid: *mut wire_cst_list_prim_u_8_strict,
        namespace: *mut wire_cst_list_prim_u_8_strict,
        ttl: *mut u64,
    ) {
        wire__crate__api__p2p_rdv__libp2p_rdv_register_impl(
            port_, wrapper, rdv_peerid, namespace, ttl,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_request__libp2p_close_response(
        port_: i64,
        channel: usize,
    ) {
        wire__crate__api__p2p_request__libp2p_close_response_impl(port_, channel)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_request__libp2p_send_request(
        port_: i64,
        wrapper: usize,
        peerid: *mut wire_cst_list_prim_u_8_strict,
        request: *mut wire_cst_list_prim_u_8_loose,
    ) {
        wire__crate__api__p2p_request__libp2p_send_request_impl(port_, wrapper, peerid, request)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_request__libp2p_send_response(
        port_: i64,
        wrapper: usize,
        channel: usize,
        response: *mut wire_cst_list_prim_u_8_loose,
    ) {
        wire__crate__api__p2p_request__libp2p_send_response_impl(port_, wrapper, channel, response)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_utils__CancellationToken_cancel(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_utils__CancellationToken_cancel_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_utils__CancellationToken_is_cancelled(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_utils__CancellationToken_is_cancelled_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_utils__create_cancellation_token(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_utils__create_cancellation_token_impl()
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_utils__libp2p_add_blacklist(
        port_: i64,
        wrapper: usize,
        peer: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__p2p_utils__libp2p_add_blacklist_impl(port_, wrapper, peer)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_utils__libp2p_add_external_address(
        wrapper: usize,
        address: *mut wire_cst_list_prim_u_8_strict,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_utils__libp2p_add_external_address_impl(wrapper, address)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_utils__libp2p_close_connection(
        port_: i64,
        wrapper: usize,
        connection_id: usize,
    ) {
        wire__crate__api__p2p_utils__libp2p_close_connection_impl(port_, wrapper, connection_id)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_utils__libp2p_peerid(
        wrapper: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_utils__libp2p_peerid_impl(wrapper)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_utils__libp2p_peerid_random(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_utils__libp2p_peerid_random_impl()
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__p2p_utils__libp2p_remove_blacklist(
        port_: i64,
        wrapper: usize,
        peer: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__p2p_utils__libp2p_remove_blacklist_impl(port_, wrapper, peer)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__sled__CustomBatch_auto_accessor_get_deletes(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__sled__CustomBatch_auto_accessor_get_deletes_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__sled__CustomBatch_auto_accessor_get_upserts(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__sled__CustomBatch_auto_accessor_get_upserts_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__sled__CustomBatch_auto_accessor_set_deletes(
        that: usize,
        deletes: *mut wire_cst_list_list_prim_u_8_strict,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__sled__CustomBatch_auto_accessor_set_deletes_impl(that, deletes)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__sled__CustomBatch_auto_accessor_set_upserts(
        that: usize,
        upserts: *mut wire_cst_list_record_list_prim_u_8_strict_list_prim_u_8_strict,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__sled__CustomBatch_auto_accessor_set_upserts_impl(that, upserts)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__sled__sled_db_close(
        port_: i64,
        db: usize,
    ) {
        wire__crate__api__sled__sled_db_close_impl(port_, db)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__sled__sled_db_contains(
        port_: i64,
        db: usize,
        key: *mut wire_cst_list_prim_u_8_loose,
        tree: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__sled__sled_db_contains_impl(port_, db, key, tree)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__sled__sled_db_count(
        port_: i64,
        db: usize,
        tree: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__sled__sled_db_count_impl(port_, db, tree)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__sled__sled_db_delete(
        port_: i64,
        db: usize,
        key: *mut wire_cst_list_prim_u_8_loose,
        tree: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__sled__sled_db_delete_impl(port_, db, key, tree)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__sled__sled_db_delete_all(
        port_: i64,
        db: usize,
        tree: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__sled__sled_db_delete_all_impl(port_, db, tree)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__sled__sled_db_drop(
        port_: i64,
        db: usize,
        tree: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__sled__sled_db_drop_impl(port_, db, tree)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__sled__sled_db_flush(
        port_: i64,
        db: usize,
        tree: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__sled__sled_db_flush_impl(port_, db, tree)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__sled__sled_db_get(
        port_: i64,
        db: usize,
        key: *mut wire_cst_list_prim_u_8_loose,
        tree: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__sled__sled_db_get_impl(port_, db, key, tree)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__sled__sled_db_get_next(
        port_: i64,
        db: usize,
        key: *mut wire_cst_list_prim_u_8_loose,
        tree: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__sled__sled_db_get_next_impl(port_, db, key, tree)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__sled__sled_db_get_previous(
        port_: i64,
        db: usize,
        key: *mut wire_cst_list_prim_u_8_loose,
        tree: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__sled__sled_db_get_previous_impl(port_, db, key, tree)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__sled__sled_db_key_from_string(
        key: *mut wire_cst_list_prim_u_8_strict,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__sled__sled_db_key_from_string_impl(key)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__sled__sled_db_key_prefix(
        port_: i64,
        db: usize,
        prefix: *mut wire_cst_list_prim_u_8_strict,
        limit: *mut usize,
        tree: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__sled__sled_db_key_prefix_impl(port_, db, prefix, limit, tree)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__sled__sled_db_key_prefix_fn(
        port_: i64,
        db: usize,
        prefix: *mut wire_cst_list_prim_u_8_strict,
        tree: *mut wire_cst_list_prim_u_8_strict,
        callback: *const std::ffi::c_void,
    ) {
        wire__crate__api__sled__sled_db_key_prefix_fn_impl(port_, db, prefix, tree, callback)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__sled__sled_db_key_range(
        port_: i64,
        db: usize,
        start: *mut wire_cst_list_prim_u_8_strict,
        end: *mut wire_cst_list_prim_u_8_strict,
        limit: *mut usize,
        tree: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__sled__sled_db_key_range_impl(port_, db, start, end, limit, tree)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__sled__sled_db_key_range_fn(
        port_: i64,
        db: usize,
        start: *mut wire_cst_list_prim_u_8_strict,
        end: *mut wire_cst_list_prim_u_8_strict,
        tree: *mut wire_cst_list_prim_u_8_strict,
        callback: *const std::ffi::c_void,
    ) {
        wire__crate__api__sled__sled_db_key_range_fn_impl(port_, db, start, end, tree, callback)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__sled__sled_db_key_to_string(
        key: *mut wire_cst_list_prim_u_8_loose,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__sled__sled_db_key_to_string_impl(key)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__sled__sled_db_key_value_prefix(
        port_: i64,
        db: usize,
        prefix: *mut wire_cst_list_prim_u_8_strict,
        limit: *mut usize,
        tree: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__sled__sled_db_key_value_prefix_impl(port_, db, prefix, limit, tree)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__sled__sled_db_key_value_prefix_fn(
        port_: i64,
        db: usize,
        prefix: *mut wire_cst_list_prim_u_8_strict,
        tree: *mut wire_cst_list_prim_u_8_strict,
        callback: *const std::ffi::c_void,
    ) {
        wire__crate__api__sled__sled_db_key_value_prefix_fn_impl(port_, db, prefix, tree, callback)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__sled__sled_db_key_value_range(
        port_: i64,
        db: usize,
        start: *mut wire_cst_list_prim_u_8_strict,
        end: *mut wire_cst_list_prim_u_8_strict,
        limit: *mut usize,
        tree: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__sled__sled_db_key_value_range_impl(port_, db, start, end, limit, tree)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__sled__sled_db_key_value_range_fn(
        port_: i64,
        db: usize,
        start: *mut wire_cst_list_prim_u_8_strict,
        end: *mut wire_cst_list_prim_u_8_strict,
        tree: *mut wire_cst_list_prim_u_8_strict,
        callback: *const std::ffi::c_void,
    ) {
        wire__crate__api__sled__sled_db_key_value_range_fn_impl(
            port_, db, start, end, tree, callback,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__sled__sled_db_open(
        port_: i64,
        path: *mut wire_cst_list_prim_u_8_strict,
        compression: bool,
        temporary: bool,
    ) {
        wire__crate__api__sled__sled_db_open_impl(port_, path, compression, temporary)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__sled__sled_db_transaction_begin(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__sled__sled_db_transaction_begin_impl()
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__sled__sled_db_transaction_commit(
        port_: i64,
        db: usize,
        batch: usize,
        tree: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__sled__sled_db_transaction_commit_impl(port_, db, batch, tree)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_wire__crate__api__sled__sled_db_upsert(
        port_: i64,
        db: usize,
        key: *mut wire_cst_list_prim_u_8_loose,
        value: *mut wire_cst_list_prim_u_8_loose,
        tree: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__sled__sled_db_upsert_impl(port_, db, key, value, tree)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcCustomDB(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < CustomDB >>>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcCustomDB(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < CustomDB >>>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcWrapper(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < Wrapper >>>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcWrapper(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < Wrapper >>>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancellationToken(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CancellationToken>>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancellationToken(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CancellationToken>>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConnectionId(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConnectionId>>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConnectionId(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConnectionId>>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCookie(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Cookie>>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCookie(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Cookie>>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCustomBatch(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CustomBatch>>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCustomBatch(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CustomBatch>>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerKeypair(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Keypair>>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerKeypair(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Keypair>>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListenerId(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ListenerId>>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListenerId(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ListenerId>>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessageId(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessageId>>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessageId(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessageId>>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeerId(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerId>>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeerId(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerId>>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPublicKey(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPublicKey(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResponseChannelVecu8(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ResponseChannel<Vec<u8>>>,
            >::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResponseChannelVecu8(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ResponseChannel<Vec<u8>>>,
            >::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_cst_new_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCookie(
        value: usize,
    ) -> *mut usize {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_cst_new_box_autoadd_custom_nat_status(
    ) -> *mut wire_cst_custom_nat_status {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_custom_nat_status::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_cst_new_box_autoadd_custom_swarm_event(
    ) -> *mut wire_cst_custom_swarm_event {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_custom_swarm_event::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_cst_new_box_autoadd_record_list_prim_u_8_strict_list_prim_u_8_strict(
    ) -> *mut wire_cst_record_list_prim_u_8_strict_list_prim_u_8_strict {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_record_list_prim_u_8_strict_list_prim_u_8_strict::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_cst_new_box_autoadd_u_32(value: u32) -> *mut u32 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_cst_new_box_autoadd_u_64(value: u64) -> *mut u64 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_cst_new_box_autoadd_usize(value: usize) -> *mut usize {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_cst_new_list_String(
        len: i32,
    ) -> *mut wire_cst_list_String {
        let wrap = wire_cst_list_String {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <*mut wire_cst_list_prim_u_8_strict>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_cst_new_list_custom_peer_record(
        len: i32,
    ) -> *mut wire_cst_list_custom_peer_record {
        let wrap = wire_cst_list_custom_peer_record {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_custom_peer_record>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_cst_new_list_list_prim_u_8_strict(
        len: i32,
    ) -> *mut wire_cst_list_list_prim_u_8_strict {
        let wrap = wire_cst_list_list_prim_u_8_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <*mut wire_cst_list_prim_u_8_strict>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_cst_new_list_prim_u_8_loose(
        len: i32,
    ) -> *mut wire_cst_list_prim_u_8_loose {
        let ans = wire_cst_list_prim_u_8_loose {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_cst_new_list_prim_u_8_strict(
        len: i32,
    ) -> *mut wire_cst_list_prim_u_8_strict {
        let ans = wire_cst_list_prim_u_8_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_denarius_core_cst_new_list_record_list_prim_u_8_strict_list_prim_u_8_strict(
        len: i32,
    ) -> *mut wire_cst_list_record_list_prim_u_8_strict_list_prim_u_8_strict {
        let wrap = wire_cst_list_record_list_prim_u_8_strict_list_prim_u_8_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_record_list_prim_u_8_strict_list_prim_u_8_strict>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_custom_nat_status {
        tag: i32,
        kind: CustomNatStatusKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union CustomNatStatusKind {
        Public: wire_cst_CustomNatStatus_Public,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomNatStatus_Public {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_custom_peer_record {
        peer_id: *mut wire_cst_list_prim_u_8_strict,
        addresses: *mut wire_cst_list_String,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_custom_swarm_event {
        tag: i32,
        kind: CustomSwarmEventKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union CustomSwarmEventKind {
        UpnpNewExternalAddr: wire_cst_CustomSwarmEvent_UpnpNewExternalAddr,
        UpnpExpiredExternalAddr: wire_cst_CustomSwarmEvent_UpnpExpiredExternalAddr,
        NATStatusChanged: wire_cst_CustomSwarmEvent_NATStatusChanged,
        RequestMessage: wire_cst_CustomSwarmEvent_RequestMessage,
        ResponseMessage: wire_cst_CustomSwarmEvent_ResponseMessage,
        RequestOutboundFailure: wire_cst_CustomSwarmEvent_RequestOutboundFailure,
        RequestInboundFailure: wire_cst_CustomSwarmEvent_RequestInboundFailure,
        ResponseSent: wire_cst_CustomSwarmEvent_ResponseSent,
        RdvClientDiscovered: wire_cst_CustomSwarmEvent_RdvClientDiscovered,
        RdvClientDiscoveryFail: wire_cst_CustomSwarmEvent_RdvClientDiscoveryFail,
        RdvClientRegistered: wire_cst_CustomSwarmEvent_RdvClientRegistered,
        RdvClientRegisteredFailed: wire_cst_CustomSwarmEvent_RdvClientRegisteredFailed,
        RdvClientDiscoveryExpired: wire_cst_CustomSwarmEvent_RdvClientDiscoveryExpired,
        RdvServerPeerRegistered: wire_cst_CustomSwarmEvent_RdvServerPeerRegistered,
        RdvServerPeerUnRegistered: wire_cst_CustomSwarmEvent_RdvServerPeerUnRegistered,
        RdvServerPeerExpired: wire_cst_CustomSwarmEvent_RdvServerPeerExpired,
        IdentifyReceived: wire_cst_CustomSwarmEvent_IdentifyReceived,
        GossipMessage: wire_cst_CustomSwarmEvent_GossipMessage,
        GossipSubscribed: wire_cst_CustomSwarmEvent_GossipSubscribed,
        GossipUnsubscribed: wire_cst_CustomSwarmEvent_GossipUnsubscribed,
        GossipsubNotSupported: wire_cst_CustomSwarmEvent_GossipsubNotSupported,
        ConnectionEstablished: wire_cst_CustomSwarmEvent_ConnectionEstablished,
        ConnectionClosed: wire_cst_CustomSwarmEvent_ConnectionClosed,
        IncomingConnection: wire_cst_CustomSwarmEvent_IncomingConnection,
        IncomingConnectionError: wire_cst_CustomSwarmEvent_IncomingConnectionError,
        OutgoingConnectionError: wire_cst_CustomSwarmEvent_OutgoingConnectionError,
        NewListenAddr: wire_cst_CustomSwarmEvent_NewListenAddr,
        ExpiredListenAddr: wire_cst_CustomSwarmEvent_ExpiredListenAddr,
        ListenerClosed: wire_cst_CustomSwarmEvent_ListenerClosed,
        ListenerError: wire_cst_CustomSwarmEvent_ListenerError,
        Dialing: wire_cst_CustomSwarmEvent_Dialing,
        NewExternalAddrCandidate: wire_cst_CustomSwarmEvent_NewExternalAddrCandidate,
        ExternalAddrConfirmed: wire_cst_CustomSwarmEvent_ExternalAddrConfirmed,
        ExternalAddrExpired: wire_cst_CustomSwarmEvent_ExternalAddrExpired,
        NewExternalAddrOfPeer: wire_cst_CustomSwarmEvent_NewExternalAddrOfPeer,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_UpnpNewExternalAddr {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_UpnpExpiredExternalAddr {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_NATStatusChanged {
        old_value: *mut wire_cst_custom_nat_status,
        new_value: *mut wire_cst_custom_nat_status,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_RequestMessage {
        request_id: *mut wire_cst_list_prim_u_8_strict,
        peer: *mut wire_cst_list_prim_u_8_strict,
        message: *mut wire_cst_list_prim_u_8_strict,
        channel: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_ResponseMessage {
        request_id: *mut wire_cst_list_prim_u_8_strict,
        peer: *mut wire_cst_list_prim_u_8_strict,
        message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_RequestOutboundFailure {
        peer: *mut wire_cst_list_prim_u_8_strict,
        request_id: *mut wire_cst_list_prim_u_8_strict,
        error: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_RequestInboundFailure {
        peer: *mut wire_cst_list_prim_u_8_strict,
        request_id: *mut wire_cst_list_prim_u_8_strict,
        error: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_ResponseSent {
        peer: *mut wire_cst_list_prim_u_8_strict,
        request_id: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_RdvClientDiscovered {
        rendezvous_node: *mut wire_cst_list_prim_u_8_strict,
        registrations: *mut wire_cst_list_custom_peer_record,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_RdvClientDiscoveryFail {
        rendezvous_node: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_RdvClientRegistered {
        rendezvous_node: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_RdvClientRegisteredFailed {
        rendezvous_node: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_RdvClientDiscoveryExpired {
        peer_id: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_RdvServerPeerRegistered {
        peerid: *mut wire_cst_list_prim_u_8_strict,
        addresses: *mut wire_cst_list_String,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_RdvServerPeerUnRegistered {
        peerid: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_RdvServerPeerExpired {
        peerid: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_IdentifyReceived {
        peer_id: *mut wire_cst_list_prim_u_8_strict,
        public_key: *mut wire_cst_list_prim_u_8_strict,
        protocol_version: *mut wire_cst_list_prim_u_8_strict,
        agent_version: *mut wire_cst_list_prim_u_8_strict,
        listen_addrs: *mut wire_cst_list_String,
        protocols: *mut wire_cst_list_String,
        observed_addr: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_GossipMessage {
        propagation_source: *mut wire_cst_list_prim_u_8_strict,
        message_id: *mut wire_cst_list_prim_u_8_strict,
        message: *mut wire_cst_list_prim_u_8_strict,
        source: *mut wire_cst_list_prim_u_8_strict,
        topic_hash: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_GossipSubscribed {
        peer_id: *mut wire_cst_list_prim_u_8_strict,
        topic: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_GossipUnsubscribed {
        peer_id: *mut wire_cst_list_prim_u_8_strict,
        topic: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_GossipsubNotSupported {
        peer_id: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_ConnectionEstablished {
        peer_id: *mut wire_cst_list_prim_u_8_strict,
        connection_id: usize,
        endpoint: *mut wire_cst_list_prim_u_8_strict,
        num_established: u32,
        established_in: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_ConnectionClosed {
        peer_id: *mut wire_cst_list_prim_u_8_strict,
        connection_id: usize,
        endpoint: *mut wire_cst_list_prim_u_8_strict,
        num_established: u32,
        cause: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_IncomingConnection {
        connection_id: usize,
        local_addr: *mut wire_cst_list_prim_u_8_strict,
        send_back_addr: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_IncomingConnectionError {
        connection_id: usize,
        local_addr: *mut wire_cst_list_prim_u_8_strict,
        send_back_addr: *mut wire_cst_list_prim_u_8_strict,
        error: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_OutgoingConnectionError {
        connection_id: usize,
        peer_id: *mut wire_cst_list_prim_u_8_strict,
        error: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_NewListenAddr {
        listener_id: *mut wire_cst_list_prim_u_8_strict,
        address: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_ExpiredListenAddr {
        listener_id: *mut wire_cst_list_prim_u_8_strict,
        address: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_ListenerClosed {
        listener_id: *mut wire_cst_list_prim_u_8_strict,
        addresses: *mut wire_cst_list_String,
        reason: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_ListenerError {
        listener_id: *mut wire_cst_list_prim_u_8_strict,
        error: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_Dialing {
        peer_id: *mut wire_cst_list_prim_u_8_strict,
        connection_id: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_NewExternalAddrCandidate {
        address: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_ExternalAddrConfirmed {
        address: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_ExternalAddrExpired {
        address: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CustomSwarmEvent_NewExternalAddrOfPeer {
        peer_id: *mut wire_cst_list_prim_u_8_strict,
        address: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_generic_error {
        tag: i32,
        kind: GenericErrorKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union GenericErrorKind {
        Other: wire_cst_GenericError_Other,
        Bytes: wire_cst_GenericError_Bytes,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_GenericError_Other {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_GenericError_Bytes {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_String {
        ptr: *mut *mut wire_cst_list_prim_u_8_strict,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_custom_peer_record {
        ptr: *mut wire_cst_custom_peer_record,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_list_prim_u_8_strict {
        ptr: *mut *mut wire_cst_list_prim_u_8_strict,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_8_loose {
        ptr: *mut u8,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_8_strict {
        ptr: *mut u8,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_record_list_prim_u_8_strict_list_prim_u_8_strict {
        ptr: *mut wire_cst_record_list_prim_u_8_strict_list_prim_u_8_strict,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_record_list_prim_u_8_strict_list_prim_u_8_strict {
        field0: *mut wire_cst_list_prim_u_8_strict,
        field1: *mut wire_cst_list_prim_u_8_strict,
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
mod web {
    // This file is automatically generated, so please do not edit it.
    // Generated by `flutter_rust_bridge`@ 2.2.0.

    // Section: imports

    use super::*;
    use crate::api::p2p_common::*;
    use crate::api::p2p_dial::*;
    use crate::api::p2p_event::*;
    use crate::api::p2p_key::*;
    use crate::api::p2p_rdv::*;
    use crate::api::p2p_utils::*;
    use crate::api::sled::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::wasm_bindgen;
    use flutter_rust_bridge::for_generated::wasm_bindgen::prelude::*;
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_web!();

    // Section: dart2rust

    impl CstDecode<flutter_rust_bridge::for_generated::anyhow::Error> for String {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> flutter_rust_bridge::for_generated::anyhow::Error {
            unimplemented!()
        }
    }
    impl CstDecode<flutter_rust_bridge::DartOpaque>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> flutter_rust_bridge::DartOpaque {
            unsafe { flutter_rust_bridge::for_generated::cst_decode_dart_opaque(self as _) }
        }
    }
    impl CstDecode<String> for String {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> String {
            self
        }
    }
    impl CstDecode<u128> for String {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u128 {
            CstDecode::<String>::cst_decode(self).parse().unwrap()
        }
    }
    impl CstDecode<crate::api::p2p_common::CustomNatStatus>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::p2p_common::CustomNatStatus {
            let self_ = self.unchecked_into::<flutter_rust_bridge::for_generated::js_sys::Array>();
            match self_.get(0).unchecked_into_f64() as _ {
                0 => crate::api::p2p_common::CustomNatStatus::Public(self_.get(1).cst_decode()),
                1 => crate::api::p2p_common::CustomNatStatus::Private,
                2 => crate::api::p2p_common::CustomNatStatus::Unknown,
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::p2p_common::CustomPeerRecord>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::p2p_common::CustomPeerRecord {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            crate::api::p2p_common::CustomPeerRecord {
                peer_id: self_.get(0).cst_decode(),
                addresses: self_.get(1).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::p2p_common::CustomSwarmEvent>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::p2p_common::CustomSwarmEvent {
            let self_ = self.unchecked_into::<flutter_rust_bridge::for_generated::js_sys::Array>();
            match self_.get(0).unchecked_into_f64() as _ {
                0 => crate::api::p2p_common::CustomSwarmEvent::UpnpNewExternalAddr(
                    self_.get(1).cst_decode(),
                ),
                1 => crate::api::p2p_common::CustomSwarmEvent::UpnpExpiredExternalAddr(
                    self_.get(1).cst_decode(),
                ),
                2 => crate::api::p2p_common::CustomSwarmEvent::UpnpGatewayNotFound,
                3 => crate::api::p2p_common::CustomSwarmEvent::UpnpNonRoutableGateway,
                4 => crate::api::p2p_common::CustomSwarmEvent::NATStatusChanged {
                    old_value: self_.get(1).cst_decode(),
                    new_value: self_.get(2).cst_decode(),
                },
                5 => crate::api::p2p_common::CustomSwarmEvent::RequestMessage {
                    request_id: self_.get(1).cst_decode(),
                    peer: self_.get(2).cst_decode(),
                    message: self_.get(3).cst_decode(),
                    channel: self_.get(4).cst_decode(),
                },
                6 => crate::api::p2p_common::CustomSwarmEvent::ResponseMessage {
                    request_id: self_.get(1).cst_decode(),
                    peer: self_.get(2).cst_decode(),
                    message: self_.get(3).cst_decode(),
                },
                7 => crate::api::p2p_common::CustomSwarmEvent::RequestOutboundFailure {
                    peer: self_.get(1).cst_decode(),
                    request_id: self_.get(2).cst_decode(),
                    error: self_.get(3).cst_decode(),
                },
                8 => crate::api::p2p_common::CustomSwarmEvent::RequestInboundFailure {
                    peer: self_.get(1).cst_decode(),
                    request_id: self_.get(2).cst_decode(),
                    error: self_.get(3).cst_decode(),
                },
                9 => crate::api::p2p_common::CustomSwarmEvent::ResponseSent {
                    peer: self_.get(1).cst_decode(),
                    request_id: self_.get(2).cst_decode(),
                },
                10 => crate::api::p2p_common::CustomSwarmEvent::RdvClientDiscovered {
                    rendezvous_node: self_.get(1).cst_decode(),
                    registrations: self_.get(2).cst_decode(),
                },
                11 => crate::api::p2p_common::CustomSwarmEvent::RdvClientDiscoveryFail {
                    rendezvous_node: self_.get(1).cst_decode(),
                },
                12 => crate::api::p2p_common::CustomSwarmEvent::RdvClientRegistered {
                    rendezvous_node: self_.get(1).cst_decode(),
                },
                13 => crate::api::p2p_common::CustomSwarmEvent::RdvClientRegisteredFailed {
                    rendezvous_node: self_.get(1).cst_decode(),
                },
                14 => crate::api::p2p_common::CustomSwarmEvent::RdvClientDiscoveryExpired {
                    peer_id: self_.get(1).cst_decode(),
                },
                15 => crate::api::p2p_common::CustomSwarmEvent::RdvServerPeerRegistered {
                    peerid: self_.get(1).cst_decode(),
                    addresses: self_.get(2).cst_decode(),
                },
                16 => crate::api::p2p_common::CustomSwarmEvent::RdvServerPeerUnRegistered {
                    peerid: self_.get(1).cst_decode(),
                },
                17 => crate::api::p2p_common::CustomSwarmEvent::RdvServerPeerExpired {
                    peerid: self_.get(1).cst_decode(),
                },
                18 => crate::api::p2p_common::CustomSwarmEvent::IdentifyReceived {
                    peer_id: self_.get(1).cst_decode(),
                    public_key: self_.get(2).cst_decode(),
                    protocol_version: self_.get(3).cst_decode(),
                    agent_version: self_.get(4).cst_decode(),
                    listen_addrs: self_.get(5).cst_decode(),
                    protocols: self_.get(6).cst_decode(),
                    observed_addr: self_.get(7).cst_decode(),
                },
                19 => crate::api::p2p_common::CustomSwarmEvent::GossipMessage {
                    propagation_source: self_.get(1).cst_decode(),
                    message_id: self_.get(2).cst_decode(),
                    message: self_.get(3).cst_decode(),
                    source: self_.get(4).cst_decode(),
                    topic_hash: self_.get(5).cst_decode(),
                },
                20 => crate::api::p2p_common::CustomSwarmEvent::GossipSubscribed {
                    peer_id: self_.get(1).cst_decode(),
                    topic: self_.get(2).cst_decode(),
                },
                21 => crate::api::p2p_common::CustomSwarmEvent::GossipUnsubscribed {
                    peer_id: self_.get(1).cst_decode(),
                    topic: self_.get(2).cst_decode(),
                },
                22 => crate::api::p2p_common::CustomSwarmEvent::GossipsubNotSupported {
                    peer_id: self_.get(1).cst_decode(),
                },
                23 => crate::api::p2p_common::CustomSwarmEvent::ConnectionEstablished {
                    peer_id: self_.get(1).cst_decode(),
                    connection_id: self_.get(2).cst_decode(),
                    endpoint: self_.get(3).cst_decode(),
                    num_established: self_.get(4).cst_decode(),
                    established_in: self_.get(5).cst_decode(),
                },
                24 => crate::api::p2p_common::CustomSwarmEvent::ConnectionClosed {
                    peer_id: self_.get(1).cst_decode(),
                    connection_id: self_.get(2).cst_decode(),
                    endpoint: self_.get(3).cst_decode(),
                    num_established: self_.get(4).cst_decode(),
                    cause: self_.get(5).cst_decode(),
                },
                25 => crate::api::p2p_common::CustomSwarmEvent::IncomingConnection {
                    connection_id: self_.get(1).cst_decode(),
                    local_addr: self_.get(2).cst_decode(),
                    send_back_addr: self_.get(3).cst_decode(),
                },
                26 => crate::api::p2p_common::CustomSwarmEvent::IncomingConnectionError {
                    connection_id: self_.get(1).cst_decode(),
                    local_addr: self_.get(2).cst_decode(),
                    send_back_addr: self_.get(3).cst_decode(),
                    error: self_.get(4).cst_decode(),
                },
                27 => crate::api::p2p_common::CustomSwarmEvent::OutgoingConnectionError {
                    connection_id: self_.get(1).cst_decode(),
                    peer_id: self_.get(2).cst_decode(),
                    error: self_.get(3).cst_decode(),
                },
                28 => crate::api::p2p_common::CustomSwarmEvent::NewListenAddr {
                    listener_id: self_.get(1).cst_decode(),
                    address: self_.get(2).cst_decode(),
                },
                29 => crate::api::p2p_common::CustomSwarmEvent::ExpiredListenAddr {
                    listener_id: self_.get(1).cst_decode(),
                    address: self_.get(2).cst_decode(),
                },
                30 => crate::api::p2p_common::CustomSwarmEvent::ListenerClosed {
                    listener_id: self_.get(1).cst_decode(),
                    addresses: self_.get(2).cst_decode(),
                    reason: self_.get(3).cst_decode(),
                },
                31 => crate::api::p2p_common::CustomSwarmEvent::ListenerError {
                    listener_id: self_.get(1).cst_decode(),
                    error: self_.get(2).cst_decode(),
                },
                32 => crate::api::p2p_common::CustomSwarmEvent::Dialing {
                    peer_id: self_.get(1).cst_decode(),
                    connection_id: self_.get(2).cst_decode(),
                },
                33 => crate::api::p2p_common::CustomSwarmEvent::NewExternalAddrCandidate {
                    address: self_.get(1).cst_decode(),
                },
                34 => crate::api::p2p_common::CustomSwarmEvent::ExternalAddrConfirmed {
                    address: self_.get(1).cst_decode(),
                },
                35 => crate::api::p2p_common::CustomSwarmEvent::ExternalAddrExpired {
                    address: self_.get(1).cst_decode(),
                },
                36 => crate::api::p2p_common::CustomSwarmEvent::NewExternalAddrOfPeer {
                    peer_id: self_.get(1).cst_decode(),
                    address: self_.get(2).cst_decode(),
                },
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::p2p_common::GenericError>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::p2p_common::GenericError {
            let self_ = self.unchecked_into::<flutter_rust_bridge::for_generated::js_sys::Array>();
            match self_.get(0).unchecked_into_f64() as _ {
                0 => crate::api::p2p_common::GenericError::InstanceNotFound,
                1 => crate::api::p2p_common::GenericError::BadAddress,
                2 => crate::api::p2p_common::GenericError::Other(self_.get(1).cst_decode()),
                3 => crate::api::p2p_common::GenericError::Bytes(self_.get(1).cst_decode()),
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<Vec<String>> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<String> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<crate::api::p2p_common::CustomPeerRecord>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::p2p_common::CustomPeerRecord> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<Vec<u8>>> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<Vec<u8>> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<u8>> for Box<[u8]> {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            self.into_vec()
        }
    }
    impl CstDecode<Vec<(Vec<u8>, Vec<u8>)>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<(Vec<u8>, Vec<u8>)> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Option<String>> for Option<String> {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Option<String> {
            self.map(CstDecode::cst_decode)
        }
    }
    impl CstDecode<Option<Vec<u8>>> for Option<Box<[u8]>> {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Option<Vec<u8>> {
            self.map(CstDecode::cst_decode)
        }
    }
    impl CstDecode<(Vec<u8>, Vec<u8>)> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> (Vec<u8>, Vec<u8>) {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            (self_.get(0).cst_decode(), self_.get(1).cst_decode())
        }
    }
    impl CstDecode<flutter_rust_bridge::for_generated::anyhow::Error>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> flutter_rust_bridge::for_generated::anyhow::Error {
            unimplemented!()
        }
    }
    impl CstDecode<RustAutoOpaqueNom<ResponseChannel<Vec<u8>>>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustAutoOpaqueNom<ResponseChannel<Vec<u8>>> {
            flutter_rust_bridge::for_generated::rust_auto_opaque_explicit_decode(self.cst_decode())
        }
    }
    impl CstDecode<Arc<CustomDB>> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Arc<CustomDB> {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<CustomDB>>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<Arc<Wrapper>> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Arc<Wrapper> {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<CancellationToken> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> CancellationToken {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CancellationToken>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<ConnectionId> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ConnectionId {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConnectionId>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<Cookie> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Cookie {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Cookie>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<CustomBatch> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> CustomBatch {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CustomBatch>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<Keypair> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Keypair {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Keypair>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<ListenerId> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ListenerId {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ListenerId>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<MessageId> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> MessageId {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessageId>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<PeerId> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> PeerId {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerId>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<PublicKey> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> PublicKey {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<ResponseChannel<Vec<u8>>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ResponseChannel<Vec<u8>> {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                        ResponseChannel<Vec<u8>>,
                    >,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<CustomDB>>>,
        > for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<CustomDB>>>
        {
            #[cfg(target_pointer_width = "64")]
            {
                compile_error!("64-bit pointers are not supported.");
            }
            unsafe { decode_rust_opaque_nom((self.as_f64().unwrap() as usize) as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>,
        > for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Wrapper>>>
        {
            #[cfg(target_pointer_width = "64")]
            {
                compile_error!("64-bit pointers are not supported.");
            }
            unsafe { decode_rust_opaque_nom((self.as_f64().unwrap() as usize) as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CancellationToken>,
            >,
        > for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CancellationToken>>
        {
            #[cfg(target_pointer_width = "64")]
            {
                compile_error!("64-bit pointers are not supported.");
            }
            unsafe { decode_rust_opaque_nom((self.as_f64().unwrap() as usize) as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConnectionId>>,
        > for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConnectionId>>
        {
            #[cfg(target_pointer_width = "64")]
            {
                compile_error!("64-bit pointers are not supported.");
            }
            unsafe { decode_rust_opaque_nom((self.as_f64().unwrap() as usize) as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Cookie>>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Cookie>>
        {
            #[cfg(target_pointer_width = "64")]
            {
                compile_error!("64-bit pointers are not supported.");
            }
            unsafe { decode_rust_opaque_nom((self.as_f64().unwrap() as usize) as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CustomBatch>>,
        > for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CustomBatch>>
        {
            #[cfg(target_pointer_width = "64")]
            {
                compile_error!("64-bit pointers are not supported.");
            }
            unsafe { decode_rust_opaque_nom((self.as_f64().unwrap() as usize) as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Keypair>>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Keypair>>
        {
            #[cfg(target_pointer_width = "64")]
            {
                compile_error!("64-bit pointers are not supported.");
            }
            unsafe { decode_rust_opaque_nom((self.as_f64().unwrap() as usize) as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ListenerId>>,
        > for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ListenerId>>
        {
            #[cfg(target_pointer_width = "64")]
            {
                compile_error!("64-bit pointers are not supported.");
            }
            unsafe { decode_rust_opaque_nom((self.as_f64().unwrap() as usize) as _) }
        }
    }
    impl
        CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessageId>>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessageId>>
        {
            #[cfg(target_pointer_width = "64")]
            {
                compile_error!("64-bit pointers are not supported.");
            }
            unsafe { decode_rust_opaque_nom((self.as_f64().unwrap() as usize) as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerId>>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerId>>
        {
            #[cfg(target_pointer_width = "64")]
            {
                compile_error!("64-bit pointers are not supported.");
            }
            unsafe { decode_rust_opaque_nom((self.as_f64().unwrap() as usize) as _) }
        }
    }
    impl
        CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>
        {
            #[cfg(target_pointer_width = "64")]
            {
                compile_error!("64-bit pointers are not supported.");
            }
            unsafe { decode_rust_opaque_nom((self.as_f64().unwrap() as usize) as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ResponseChannel<Vec<u8>>>,
            >,
        > for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ResponseChannel<Vec<u8>>>,
        > {
            #[cfg(target_pointer_width = "64")]
            {
                compile_error!("64-bit pointers are not supported.");
            }
            unsafe { decode_rust_opaque_nom((self.as_f64().unwrap() as usize) as _) }
        }
    }
    impl CstDecode<String> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> String {
            self.as_string().expect("non-UTF-8 string, or not a string")
        }
    }
    impl CstDecode<u128> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u128 {
            CstDecode::<String>::cst_decode(self).parse().unwrap()
        }
    }
    impl CstDecode<bool> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> bool {
            self.is_truthy()
        }
    }
    impl CstDecode<crate::api::p2p_pubsub::CustomMessageAcceptance>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::p2p_pubsub::CustomMessageAcceptance {
            (self.unchecked_into_f64() as i32).cst_decode()
        }
    }
    impl CstDecode<f64> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> f64 {
            self.unchecked_into_f64() as _
        }
    }
    impl CstDecode<i32> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> i32 {
            self.unchecked_into_f64() as _
        }
    }
    impl CstDecode<crate::api::p2p_key::KeyType>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::p2p_key::KeyType {
            (self.unchecked_into_f64() as i32).cst_decode()
        }
    }
    impl CstDecode<Vec<u8>> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            self.unchecked_into::<flutter_rust_bridge::for_generated::js_sys::Uint8Array>()
                .to_vec()
                .into()
        }
    }
    impl CstDecode<u32> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u32 {
            self.unchecked_into_f64() as _
        }
    }
    impl CstDecode<u64> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u64 {
            ::std::convert::TryInto::<u64>::try_into(self).unwrap() as _
        }
    }
    impl CstDecode<u8> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u8 {
            self.unchecked_into_f64() as _
        }
    }
    impl CstDecode<usize> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> usize {
            ::std::convert::TryInto::<u64>::try_into(self).unwrap() as _
        }
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__minimal__init_app(
        port_: flutter_rust_bridge::for_generated::MessagePort,
    ) {
        wire__crate__api__minimal__init_app_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_common__ConnectionId_to_string(
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_common__ConnectionId_to_string_impl(that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_common__ListenerId_to_string(
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_common__ListenerId_to_string_impl(that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_common__MessageId_to_string(
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_common__MessageId_to_string_impl(that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_dial__libp2p_connected_peers(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wrapper: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__p2p_dial__libp2p_connected_peers_impl(port_, wrapper)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_dial__libp2p_connected_peers_count(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wrapper: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__p2p_dial__libp2p_connected_peers_count_impl(port_, wrapper)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_dial__libp2p_dial_address(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wrapper: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        address: String,
    ) {
        wire__crate__api__p2p_dial__libp2p_dial_address_impl(port_, wrapper, address)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_dial__libp2p_dial_peer(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wrapper: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        peerid: String,
    ) {
        wire__crate__api__p2p_dial__libp2p_dial_peer_impl(port_, wrapper, peerid)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_dial__libp2p_disconnect_peer(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wrapper: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        peerid: String,
    ) {
        wire__crate__api__p2p_dial__libp2p_disconnect_peer_impl(port_, wrapper, peerid)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_dial__libp2p_isconnected(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wrapper: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        peer: String,
    ) {
        wire__crate__api__p2p_dial__libp2p_isconnected_impl(port_, wrapper, peer)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_event__libp2p_add_event_listener(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wrapper: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        cancellation_token: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        callback: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__p2p_event__libp2p_add_event_listener_impl(
            port_,
            wrapper,
            cancellation_token,
            callback,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_event__libp2p_get_event_name(
        event: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_event__libp2p_get_event_name_impl(event)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_factory__create_libp2p_instance(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        keypair: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        tcp_nodelay: bool,
        tcp_reuse_port: bool,
        pubsub_heartbeat_delay: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        pubsub_heartbeat_interval: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        nat_boot_delay: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        nat_retry_interval: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        nat_only_global_ips: bool,
        nat_use_connected: bool,
        connection_max_inout: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        connection_max_inbound: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        connection_max_outgoing: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        connection_max_pending_inbound: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        connection_max_pending_outgoing: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        memory_max_percentage: f64,
    ) {
        wire__crate__api__p2p_factory__create_libp2p_instance_impl(
            port_,
            keypair,
            tcp_nodelay,
            tcp_reuse_port,
            pubsub_heartbeat_delay,
            pubsub_heartbeat_interval,
            nat_boot_delay,
            nat_retry_interval,
            nat_only_global_ips,
            nat_use_connected,
            connection_max_inout,
            connection_max_inbound,
            connection_max_outgoing,
            connection_max_pending_inbound,
            connection_max_pending_outgoing,
            memory_max_percentage,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_key__Keypair_public(
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_key__Keypair_public_impl(that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_key__PeerId_to_base58(
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_key__PeerId_to_base58_impl(that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_key__PeerId_to_bytes(
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_key__PeerId_to_bytes_impl(that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_key__PublicKey_encode_protobuf(
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_key__PublicKey_encode_protobuf_impl(that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_key__PublicKey_to_peer_id(
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_key__PublicKey_to_peer_id_impl(that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_key__create_keypair_from_bytes(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        key_type: i32,
        bytes: Box<[u8]>,
    ) {
        wire__crate__api__p2p_key__create_keypair_from_bytes_impl(port_, key_type, bytes)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_key__create_keypair_using_random(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        key_type: i32,
    ) {
        wire__crate__api__p2p_key__create_keypair_using_random_impl(port_, key_type)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_key__keypair_from_protobuf(
        proto: Box<[u8]>,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_key__keypair_from_protobuf_impl(proto)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_key__keypair_sign(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        keypair: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        msg: Box<[u8]>,
    ) {
        wire__crate__api__p2p_key__keypair_sign_impl(port_, keypair, msg)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_key__keypair_to_protobuf(
        keypair: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_key__keypair_to_protobuf_impl(keypair)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_key__keypair_verify(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        key: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        msg: Box<[u8]>,
        sig: Box<[u8]>,
    ) {
        wire__crate__api__p2p_key__keypair_verify_impl(port_, key, msg, sig)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_listen__libp2p_listen(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wrapper: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        address: String,
    ) {
        wire__crate__api__p2p_listen__libp2p_listen_impl(port_, wrapper, address)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_listen__libp2p_unlisten(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wrapper: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        listener_id: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__p2p_listen__libp2p_unlisten_impl(port_, wrapper, listener_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_nat__libp2p_autonat_add_server(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wrapper: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        peer: String,
        address: Option<String>,
    ) {
        wire__crate__api__p2p_nat__libp2p_autonat_add_server_impl(port_, wrapper, peer, address)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_nat__libp2p_autonat_status(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wrapper: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__p2p_nat__libp2p_autonat_status_impl(port_, wrapper)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_pubsub__libp2p_publish(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wrapper: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        topic: String,
        data: Box<[u8]>,
    ) {
        wire__crate__api__p2p_pubsub__libp2p_publish_impl(port_, wrapper, topic, data)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_pubsub__libp2p_pubsub_add_peer(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wrapper: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        peer: String,
    ) {
        wire__crate__api__p2p_pubsub__libp2p_pubsub_add_peer_impl(port_, wrapper, peer)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_pubsub__libp2p_pubsub_remove_peer(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wrapper: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        peer: String,
    ) {
        wire__crate__api__p2p_pubsub__libp2p_pubsub_remove_peer_impl(port_, wrapper, peer)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_pubsub__libp2p_pubsub_validate(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wrapper: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        msg_id: Box<[u8]>,
        propagation_source: String,
        acceptance: i32,
    ) {
        wire__crate__api__p2p_pubsub__libp2p_pubsub_validate_impl(
            port_,
            wrapper,
            msg_id,
            propagation_source,
            acceptance,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_pubsub__libp2p_subscribe(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wrapper: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        topic: String,
    ) {
        wire__crate__api__p2p_pubsub__libp2p_subscribe_impl(port_, wrapper, topic)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_pubsub__libp2p_topic_tohash(
        topic: String,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_pubsub__libp2p_topic_tohash_impl(topic)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_pubsub__libp2p_unsubscribe(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wrapper: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        topic: String,
    ) {
        wire__crate__api__p2p_pubsub__libp2p_unsubscribe_impl(port_, wrapper, topic)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_rdv__Cookie_clone(
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_rdv__Cookie_clone_impl(that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_rdv__libp2p_rdv_cookie(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_rdv__libp2p_rdv_cookie_impl()
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_rdv__libp2p_rdv_discover(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wrapper: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        rdv_peerid: String,
        limit: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        cookie: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__p2p_rdv__libp2p_rdv_discover_impl(
            port_, wrapper, rdv_peerid, limit, cookie,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_rdv__libp2p_rdv_register(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wrapper: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        rdv_peerid: String,
        namespace: String,
        ttl: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__p2p_rdv__libp2p_rdv_register_impl(
            port_, wrapper, rdv_peerid, namespace, ttl,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_request__libp2p_close_response(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        channel: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__p2p_request__libp2p_close_response_impl(port_, channel)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_request__libp2p_send_request(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wrapper: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        peerid: String,
        request: Box<[u8]>,
    ) {
        wire__crate__api__p2p_request__libp2p_send_request_impl(port_, wrapper, peerid, request)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_request__libp2p_send_response(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wrapper: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        channel: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        response: Box<[u8]>,
    ) {
        wire__crate__api__p2p_request__libp2p_send_response_impl(port_, wrapper, channel, response)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_utils__CancellationToken_cancel(
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_utils__CancellationToken_cancel_impl(that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_utils__CancellationToken_is_cancelled(
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_utils__CancellationToken_is_cancelled_impl(that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_utils__create_cancellation_token(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_utils__create_cancellation_token_impl()
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_utils__libp2p_add_blacklist(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wrapper: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        peer: String,
    ) {
        wire__crate__api__p2p_utils__libp2p_add_blacklist_impl(port_, wrapper, peer)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_utils__libp2p_add_external_address(
        wrapper: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        address: String,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_utils__libp2p_add_external_address_impl(wrapper, address)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_utils__libp2p_close_connection(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wrapper: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        connection_id: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__p2p_utils__libp2p_close_connection_impl(port_, wrapper, connection_id)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_utils__libp2p_peerid(
        wrapper: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_utils__libp2p_peerid_impl(wrapper)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_utils__libp2p_peerid_random(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__p2p_utils__libp2p_peerid_random_impl()
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__p2p_utils__libp2p_remove_blacklist(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        wrapper: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        peer: String,
    ) {
        wire__crate__api__p2p_utils__libp2p_remove_blacklist_impl(port_, wrapper, peer)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sled__CustomBatch_auto_accessor_get_deletes(
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__sled__CustomBatch_auto_accessor_get_deletes_impl(that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sled__CustomBatch_auto_accessor_get_upserts(
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__sled__CustomBatch_auto_accessor_get_upserts_impl(that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sled__CustomBatch_auto_accessor_set_deletes(
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        deletes: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__sled__CustomBatch_auto_accessor_set_deletes_impl(that, deletes)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sled__CustomBatch_auto_accessor_set_upserts(
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        upserts: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__sled__CustomBatch_auto_accessor_set_upserts_impl(that, upserts)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sled__sled_db_close(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        db: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__sled__sled_db_close_impl(port_, db)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sled__sled_db_contains(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        db: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        key: Box<[u8]>,
        tree: Option<String>,
    ) {
        wire__crate__api__sled__sled_db_contains_impl(port_, db, key, tree)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sled__sled_db_count(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        db: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        tree: Option<String>,
    ) {
        wire__crate__api__sled__sled_db_count_impl(port_, db, tree)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sled__sled_db_delete(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        db: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        key: Box<[u8]>,
        tree: Option<String>,
    ) {
        wire__crate__api__sled__sled_db_delete_impl(port_, db, key, tree)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sled__sled_db_delete_all(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        db: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        tree: Option<String>,
    ) {
        wire__crate__api__sled__sled_db_delete_all_impl(port_, db, tree)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sled__sled_db_drop(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        db: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        tree: Option<String>,
    ) {
        wire__crate__api__sled__sled_db_drop_impl(port_, db, tree)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sled__sled_db_flush(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        db: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        tree: Option<String>,
    ) {
        wire__crate__api__sled__sled_db_flush_impl(port_, db, tree)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sled__sled_db_get(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        db: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        key: Box<[u8]>,
        tree: Option<String>,
    ) {
        wire__crate__api__sled__sled_db_get_impl(port_, db, key, tree)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sled__sled_db_get_next(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        db: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        key: Box<[u8]>,
        tree: Option<String>,
    ) {
        wire__crate__api__sled__sled_db_get_next_impl(port_, db, key, tree)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sled__sled_db_get_previous(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        db: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        key: Box<[u8]>,
        tree: Option<String>,
    ) {
        wire__crate__api__sled__sled_db_get_previous_impl(port_, db, key, tree)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sled__sled_db_key_from_string(
        key: String,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__sled__sled_db_key_from_string_impl(key)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sled__sled_db_key_prefix(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        db: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        prefix: String,
        limit: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        tree: Option<String>,
    ) {
        wire__crate__api__sled__sled_db_key_prefix_impl(port_, db, prefix, limit, tree)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sled__sled_db_key_prefix_fn(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        db: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        prefix: String,
        tree: Option<String>,
        callback: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__sled__sled_db_key_prefix_fn_impl(port_, db, prefix, tree, callback)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sled__sled_db_key_range(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        db: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        start: Option<String>,
        end: Option<String>,
        limit: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        tree: Option<String>,
    ) {
        wire__crate__api__sled__sled_db_key_range_impl(port_, db, start, end, limit, tree)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sled__sled_db_key_range_fn(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        db: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        start: Option<String>,
        end: Option<String>,
        tree: Option<String>,
        callback: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__sled__sled_db_key_range_fn_impl(port_, db, start, end, tree, callback)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sled__sled_db_key_to_string(
        key: Box<[u8]>,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__sled__sled_db_key_to_string_impl(key)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sled__sled_db_key_value_prefix(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        db: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        prefix: String,
        limit: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        tree: Option<String>,
    ) {
        wire__crate__api__sled__sled_db_key_value_prefix_impl(port_, db, prefix, limit, tree)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sled__sled_db_key_value_prefix_fn(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        db: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        prefix: String,
        tree: Option<String>,
        callback: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__sled__sled_db_key_value_prefix_fn_impl(port_, db, prefix, tree, callback)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sled__sled_db_key_value_range(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        db: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        start: Option<String>,
        end: Option<String>,
        limit: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        tree: Option<String>,
    ) {
        wire__crate__api__sled__sled_db_key_value_range_impl(port_, db, start, end, limit, tree)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sled__sled_db_key_value_range_fn(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        db: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        start: Option<String>,
        end: Option<String>,
        tree: Option<String>,
        callback: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__sled__sled_db_key_value_range_fn_impl(
            port_, db, start, end, tree, callback,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sled__sled_db_open(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        path: String,
        compression: bool,
        temporary: bool,
    ) {
        wire__crate__api__sled__sled_db_open_impl(port_, path, compression, temporary)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sled__sled_db_transaction_begin(
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__sled__sled_db_transaction_begin_impl()
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sled__sled_db_transaction_commit(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        db: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        batch: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        tree: Option<String>,
    ) {
        wire__crate__api__sled__sled_db_transaction_commit_impl(port_, db, batch, tree)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__sled__sled_db_upsert(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        db: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        key: Box<[u8]>,
        value: Box<[u8]>,
        tree: Option<String>,
    ) {
        wire__crate__api__sled__sled_db_upsert_impl(port_, db, key, value, tree)
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcCustomDB(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < CustomDB >>>::increment_strong_count(ptr as _);
        }
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcCustomDB(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < CustomDB >>>::decrement_strong_count(ptr as _);
        }
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcWrapper(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < Wrapper >>>::increment_strong_count(ptr as _);
        }
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcWrapper(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < Wrapper >>>::decrement_strong_count(ptr as _);
        }
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancellationToken(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CancellationToken>>::increment_strong_count(ptr as _);
        }
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancellationToken(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CancellationToken>>::decrement_strong_count(ptr as _);
        }
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConnectionId(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConnectionId>>::increment_strong_count(ptr as _);
        }
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConnectionId(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConnectionId>>::decrement_strong_count(ptr as _);
        }
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCookie(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Cookie>>::increment_strong_count(ptr as _);
        }
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCookie(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Cookie>>::decrement_strong_count(ptr as _);
        }
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCustomBatch(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CustomBatch>>::increment_strong_count(ptr as _);
        }
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCustomBatch(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CustomBatch>>::decrement_strong_count(ptr as _);
        }
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerKeypair(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Keypair>>::increment_strong_count(ptr as _);
        }
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerKeypair(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Keypair>>::decrement_strong_count(ptr as _);
        }
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListenerId(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ListenerId>>::increment_strong_count(ptr as _);
        }
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListenerId(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ListenerId>>::decrement_strong_count(ptr as _);
        }
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessageId(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessageId>>::increment_strong_count(ptr as _);
        }
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessageId(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessageId>>::decrement_strong_count(ptr as _);
        }
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeerId(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerId>>::increment_strong_count(ptr as _);
        }
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeerId(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerId>>::decrement_strong_count(ptr as _);
        }
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPublicKey(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>::increment_strong_count(ptr as _);
        }
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPublicKey(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>::decrement_strong_count(ptr as _);
        }
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResponseChannelVecu8(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ResponseChannel<Vec<u8>>>,
            >::increment_strong_count(ptr as _);
        }
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResponseChannelVecu8(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ResponseChannel<Vec<u8>>>,
            >::decrement_strong_count(ptr as _);
        }
    }
}
#[cfg(target_family = "wasm")]
pub use web::*;
